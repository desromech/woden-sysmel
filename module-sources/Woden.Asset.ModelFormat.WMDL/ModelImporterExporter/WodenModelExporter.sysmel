namespace Woden definition: {
namespace Assets definition: {

useNamespace: Std Serialization.
useNamespace: Std Graphics Core.
useNamespace: Std Math.

class WodenModelExporter definition: {
    field modelAsset type: ModelAssetRef.
    field isWritingTextModel type: Boolean8.

    method encodeBuffer: (buffer: ModelAssetBinaryBufferRef const ref) ::=> DOM Value := {
        let result := DOM Object rcNew.
        result _
            at: "name" asMutableString put: buffer name.

        buffer data ifNotNil: {:content :: Void |
            isWritingTextModel ifTrue: {
                result _ at: "data" asMutableString put: (Std ByteVector()
                    addAll: (content until: buffer dataSize);
                    yourself)
            } ifFalse: {
                result _ at: "dataSize" asMutableString put: buffer dataSize
            }.
        }.

        result
    }.

    method encodeBinaryBufferData: (buffer: ModelAssetBinaryBufferRef const ref) into: (out: Std IO Stream ref) ::=> Void := {
        buffer data ifNotNil: {
            out write: buffer data getPointer size: (buffer dataSize castTo: UInt32)
        }.
    }.

    method encodeBinaryBuffersDataInto: (out: Std IO Stream ref) ::=> Void := {
        modelAsset buffers do: {:each :: Void |
            self encodeBinaryBufferData: each into: out
        }.
    }.

    method encodeBuffers => DOM Value := {
        let result := DOM List rcNew.
        result _ reserve: modelAsset buffers size.
        modelAsset buffers do: {:each :: Void |
            result _ add: (self encodeBuffer:  each)
        }.
        result
    }.

    method encodeBufferView: (bufferView: ModelAssetBinaryBufferViewRef const ref) ::=> DOM Value := {
        let result := DOM Object rcNew.
        result _
            at: "name" asMutableString put: bufferView name;
            at: "buffer" asMutableString put: bufferView buffer index;
            at: "offset" asMutableString put: bufferView offset;
            at: "size" asMutableString put: bufferView size;
            at: "stride" asMutableString put: bufferView stride;
            at: "usage" asMutableString put: bufferView usage value.
        result
    }.

    method encodeBufferViews => DOM Value := {
        let result := DOM List rcNew.
        result _ reserve: modelAsset bufferViews size.
        modelAsset bufferViews do: {:each :: Void |
            result _ add: (self encodeBufferView:  each)
        }.
        result
    }.

    method encodeAccessor: (accessor: ModelAssetBinaryBufferAccessorRef const ref) ::=> DOM Value := {
        let minValue := DOM List rcNew.
        minValue _
            reserve: 4;
            add: accessor minValue x;
            add: accessor minValue y;
            add: accessor minValue z;
            add: accessor minValue w.

        let maxValue := DOM List rcNew.
        maxValue _
            reserve: 4;
            add: accessor maxValue x;
            add: accessor maxValue y;
            add: accessor maxValue z;
            add: accessor maxValue w.
        let result := DOM Object rcNew.
        result _
            at: "name" asMutableString put: accessor name;
            at: "bufferView" asMutableString put: accessor bufferView index;
            at: "offset" asMutableString put: accessor offset;
            at: "count" asMutableString put: accessor count;
            at: "minValue" asMutableString put: minValue;
            at: "maxValue" asMutableString put: maxValue;
            at: "format" asMutableString put: accessor format;
            at: "columnCount" asMutableString put: accessor columnCount.

        result
    }.

    method encodeAccessors => DOM Value := {
        let result := DOM List rcNew.
        result _ reserve: modelAsset bufferAccessors size.
        modelAsset bufferAccessors do: {:each :: Void |
            result _ add: (self encodeAccessor:  each)
        }.
        result
    }.

    method encodeImage: (image: ModelAssetImageRef const ref) ::=> DOM Value := {
        let result := DOM Object rcNew.
        result _
            at: "name" asMutableString put: image name;
            at: "uri" asMutableString put: image uri;
            at: "mimeType" asMutableString put: image mimeType;
            at: "usageMode" asMutableString put: image usageMode value.
        image bufferView ifNotNil: {
            result _ at: "bufferView" asMutableString put: image bufferView index.
        }.

        result
    }.

    method encodeImages => DOM Value := {
        let result := DOM List rcNew.
        result _ reserve: modelAsset images size.
        modelAsset images do: {:each :: Void |
            result _ add: (self encodeImage:  each)
        }.
        result
    }.

    method encodeSampler: (sampler: ModelAssetSamplerRef const ref) ::=> DOM Value := {
        let result := DOM Object rcNew.
        result _
            at: "name" asMutableString put: sampler name.

        result
    }.

    method encodeSamplers => DOM Value := {
        let result := DOM List rcNew.
        result _ reserve: modelAsset samplers size.
        modelAsset samplers do: {:each :: Void |
            result _ add: (self encodeSampler:  each)
        }.
        result
    }.

    method encodeTexture: (texture: ModelAssetTextureRef const ref) ::=> DOM Value := {
        let result := DOM Object rcNew.
        result _
            at: "name" asMutableString put: texture name.

        texture sampler ifNotNil: {
            result _ at: "sampler" asMutableString put: texture sampler index.
        }.

        texture image ifNotNil: {
            result _ at: "image" asMutableString put: texture image index.
        }.

        result
    }.

    method encodeTextures => DOM Value := {
        let result := DOM List rcNew.
        result _ reserve: modelAsset textures size.
        modelAsset textures do: {:each :: Void |
            result _ add: (self encodeTexture:  each)
        }.
        result
    }.

    method encodeMetallicRoughnessMaterial: (material: ModelAssetMetallicRoughnessMaterialRef const ref) ::=> DOM Value := {
        let baseColorFactor := DOM List rcNew.
        baseColorFactor _
            reserve: 4;
            add: material baseColorFactor x;
            add: material baseColorFactor y;
            add: material baseColorFactor z;
            add: material baseColorFactor w.

        let result := DOM Object rcNew.
        result _
            at: "baseColorFactor" asMutableString put: baseColorFactor;
            at: "metallicFactor" asMutableString put: material metallicFactor;
            at: "roughnessFactor" asMutableString put: material roughnessFactor.

        material baseColorTexture ifNotNil: {
            result _ at: "baseColorTexture" asMutableString put: material baseColorTexture index.
        }.

        material metallicRoughnessTexture ifNotNil: {
            result _ at: "metallicRoughnessTexture" asMutableString put: material metallicRoughnessTexture index.
        }.

        result
    }.

    method encodeMaterial: (material: ModelAssetMaterialRef const ref) ::=> DOM Value := {
        let emissionFactor := DOM List rcNew.
        emissionFactor _
            reserve: 3;
            add: material emissionFactor x;
            add: material emissionFactor y;
            add: material emissionFactor z.

        let result := DOM Object rcNew.
        result _
            at: "name" asMutableString put: material name;
            at: "emissionFactor" asMutableString put: emissionFactor;
            at: "doubleSided" asMutableString put: material doubleSided;
            at: "alphaCutoff" asMutableString put: material alphaCutoff;
            at: "alphaMode" asMutableString put: material alphaMode value.

        material occlusionTexture ifNotNil: {
            result _ at: "occlusionTexture" asMutableString put: material occlusionTexture index.
        }.

        material emissionTexture ifNotNil: {
            result _ at: "emissionTexture" asMutableString put: material emissionTexture index.
        }.

        material normalTexture ifNotNil: {
            result _ at: "normalTexture" asMutableString put: material normalTexture index.
        }.

        material isMetallicRoughnessMaterial ifTrue: {
            result _ at: "metallicRoughness" asMutableString put: (self encodeMetallicRoughnessMaterial: (material downCastFor: ModelAssetMetallicRoughnessMaterial)).
        }.

        result
    }.

    method encodeMaterials => DOM Value := {
        let result := DOM List rcNew.
        result _ reserve: modelAsset materials size.
        modelAsset materials do: {:each :: Void |
            result _ add: (self encodeMaterial:  each)
        }.
        result
    }.

    method encodeMeshPrimitiveAttributes: (attributes: ModelAssetMeshPrimitiveAttributesRef const ref) ::=> DOM Value := {
        let result := DOM List rcNew.
        result _ reserve: attributes attributes size.
        attributes attributes do: {:each :: Void |
            let attribute := DOM Object rcNew.
            attribute _
                at: "location" asMutableString put: each location value;
                at: "accessor" asMutableString put: each accessor index.

            result _ add: attribute
        }.

        result
    }.

    method encodeMeshPrimitive: (primitive: ModelAssetMeshPrimitiveRef const ref) ::=> DOM Value := {
        let result := DOM Object rcNew.

        result _
            at: "attributes" asMutableString put: (self encodeMeshPrimitiveAttributes: primitive attributes);
            at: "primitiveTopology" asMutableString put: primitive primitiveTopology value.

        primitive indices ifNotNil: {
            result _ at: "indices" asMutableString put: primitive indices index
        }.

        primitive material ifNotNil: {
            result _ at: "material" asMutableString put: primitive material index
        }.

        result
    }.

    method encodeMeshPrimitives: (mesh: ModelAssetMeshRef const ref) ::=> DOM Value := {
        let result := DOM List rcNew.
        result _ reserve: mesh primitives size.
        mesh primitives do: {:each :: Void |
            result _ add: (self encodeMeshPrimitive: each)
        }.

        result
    }.

    method encodeMesh: (mesh: ModelAssetMeshRef const ref) ::=> DOM Value := {
        let result := DOM Object rcNew.
        result _
            at: "name" asMutableString put: mesh name;
            at: "primitives" asMutableString put: (self encodeMeshPrimitives: mesh).

        result
    }.

    method encodeMeshes => DOM Value := {
        let result := DOM List rcNew.
        result _ reserve: modelAsset meshes size.
        modelAsset meshes do: {:each :: Void |
            result _ add: (self encodeMesh:  each)
        }.
        result
    }.

    method encodeSkeleton: (skeleton: ModelAssetSkeletonRef const ref) ::=> DOM Value := {
        let joints := DOM List rcNew.
        joints _ reserve: skeleton joints size.
        skeleton joints do: {:each :: Void |
            joints _ add: each index
        }.

        let result := DOM Object rcNew.
        result _
            at: "name" asMutableString put: skeleton name;
            at: "inverseBindMatrices" asMutableString put: skeleton inverseBindMatricesAccessor index;
            at: "joints" asMutableString put: joints;
            at: "rootJoint" asMutableString put: skeleton rootJoint index.

        result
    }.

    method encodeSkeletons => DOM Value := {
        let result := DOM List rcNew.
        result _ reserve: modelAsset skeletons size.
        modelAsset skeletons do: {:each :: Void |
            result _ add: (self encodeSkeleton:  each)
        }.
        result
    }.

    method encodeNode: (node: ModelAssetNodeRef const ref) ::=> DOM Value := {
        let scale := DOM List rcNew.
        scale _
            reserve: 3;
            add: node scale x;
            add: node scale y;
            add: node scale z.

        let translation := DOM List rcNew.
        translation _
            reserve: 3;
            add: node translation x;
            add: node translation y;
            add: node translation z.

        let rotation := DOM List rcNew.
        rotation _
            reserve: 4;
            add: node rotationQuaternion x;
            add: node rotationQuaternion y;
            add: node rotationQuaternion z;
            add: node rotationQuaternion w.

        let result := DOM Object rcNew.
        result _
            at: "name" asMutableString put: node name;
            at: "isJoint" asMutableString put: node isJoint;
            at: "hasValidJointIndex" asMutableString put: node hasValidJointIndex;
            at: "jointIndex" asMutableString put: node jointIndex;
            at: "parentJointIndex" asMutableString put: node parentJointIndex;
            at: "scale" asMutableString put: scale;
            at: "rotation" asMutableString put: rotation;
            at: "translation" asMutableString put: translation.

        node mesh ifNotNil: {
            result _ at: "mesh" asMutableString put: node mesh index
        }.
        node skeleton ifNotNil: {
            result _ at: "skeleton" asMutableString put: node skeleton index
        }.

        node children ifNotEmpty: {
            let children := DOM List rcNew.
            children _ reserve: node children size.
            node children do: {:each :: Void |
                children _ add: each index
            }.

            result _ at: "children" asMutableString put: children
        }.

        result
    }.

    method encodeNodes => DOM Value := {
        let result := DOM List rcNew.
        result _ reserve: modelAsset nodes size.
        modelAsset nodes do: {:each :: Void |
            result _ add: (self encodeNode: each)
        }.
        result
    }.

    method encodeScene: (scene: ModelAssetSceneRef const ref) ::=> DOM Value := {
        let result := DOM Object rcNew.
        result _
            at: "name" asMutableString put: scene name.

        scene rootNodes ifNotEmpty: {
            let rootNodes := DOM List rcNew.
            rootNodes _ reserve: scene rootNodes size.
            scene rootNodes do: {:each :: Void |
                rootNodes _ add: each index
            }.

            result _ at: "rootNodes" asMutableString put: rootNodes
        }.

        result
    }.

    method encodeScenes => DOM Value := {
        let result := DOM List rcNew.
        result _ reserve: modelAsset nodes size.
        modelAsset scenes do: {:each :: Void |
            result _ add: (self encodeScene: each)
        }.
        result
    }.

    method encodeAnimationSampler: (sampler: ModelAssetAnimationSamplerRef const ref) ::=> DOM Value := {
        let result := DOM Object rcNew.
        result _
            at: "inputAccessor" asMutableString put: sampler inputAccessor index;
            at: "outputAccessor" asMutableString put: sampler outputAccessor index;
            at: "interpolationMethod" asMutableString put: sampler interpolationMethod value.

        result
    }.

    method encodeAnimationSamplers: (animation: ModelAssetAnimationRef const ref) ::=> DOM Value := {
        let result := DOM List rcNew.
        result _ reserve: animation samplers size.
        animation samplers do: {:each :: Void |
            result _ add: (self encodeAnimationSampler: each)
        }.

        result
    }.

    method encodeAnimationChannel: (channel: ModelAssetAnimationChannelRef const ref) ::=> DOM Value := {
        let result := DOM Object rcNew.
        result _
            at: "sampler" asMutableString put: channel sampler index;
            at: "targetProperty" asMutableString put: channel targetProperty value.
        channel targetNode ifNotNil: {:n :: Void |
            result _ at: "targetNode" asMutableString put: n index
        }.

        result
    }.

    method encodeAnimationChannels: (animation: ModelAssetAnimationRef const ref) ::=> DOM Value := {
        let result := DOM List rcNew.
        result _ reserve: animation channels size.
        animation channels do: {:each :: Void |
            result _ add: (self encodeAnimationChannel: each)
        }.

        result
    }.

    method encodeAnimation: (animation: ModelAssetAnimationRef const ref) ::=> DOM Value := {
        let result := DOM Object rcNew.
        result _
            at: "name" asMutableString put: animation name;
            at: "samplers" asMutableString put: (self encodeAnimationSamplers: animation);
            at: "channels" asMutableString put: (self encodeAnimationChannels: animation).

        result
    }.

    method encodeAnimations => DOM Value := {
        let result := DOM List rcNew.
        result _ reserve: modelAsset animations size.
        modelAsset animations do: {:each :: Void |
            result _ add: (self encodeAnimation:  each)
        }.
        result
    }.

    method encodeModelAsset => DOM Value := {
        let object := DOM Object rcNew.
        object _
            at: "buffers" asMutableString put: self encodeBuffers;
            at: "bufferViews" asMutableString put: self encodeBufferViews;
            at: "accessors" asMutableString put: self encodeAccessors;
            at: "images" asMutableString put: self encodeImages;
            at: "samplers" asMutableString put: self encodeSamplers;
            at: "textures" asMutableString put: self encodeTextures;
            at: "materials" asMutableString put: self encodeMaterials;
            at: "meshes" asMutableString put: self encodeMeshes;
            at: "skeletons" asMutableString put: self encodeSkeletons;
            at: "nodes" asMutableString put: self encodeNodes;
            at: "scenes" asMutableString put: self encodeScenes;
            at: "animations" asMutableString put: self encodeAnimations.

        object
    }.

    method export: (theModelAsset: ModelAssetRef const ref) into: (fileReference: Std FileReference const ref) ::=> Boolean8 := {
        modelAsset := theModelAsset.
        isWritingTextModel := fileReference extension asArraySlice = "wtmdl".

        let result := self encodeModelAsset.

        let out mutable := fileReference binaryWriteStream.
        out ifNil: {
            return: false
        }.

        isWritingTextModel ifTrue: {
            JSON Writer writeValue: result onStream: out _.
        } ifFalse: {
            MessagePack Encoder encodeValue: result onStream: out _.
            self encodeBinaryBuffersDataInto: out _.
        }.

        true
    }.
}.

} ## End of namespace Assets
} ## End of namespace Woden
