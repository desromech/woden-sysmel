namespace Woden definition: {
namespace ForwardRenderer definition: {

useNamespace: Woden Runtime.
useNamespace: Stdn Graphics Core.
useNamespace: Stdn Graphics GUI.
useNamespace: Stdn Math Geometry.

#**
 * An abstract pipeline for rendering a null scene.
 *#
class ForwardSceneRenderingPipelineViewport superclass: SceneRenderingPipelineViewport; definition: {
    protected field sceneRenderingPipeline type: ForwardSceneRenderingPipelinePtr.

    protected field cameraStateBuffer type: BufferPtr.
    protected field cameraStateBinding type: ShaderResourceBindingsPtr.

    protected field lightingStateBuffer type: BufferPtr.
    protected field lightingStateBinding type: ShaderResourceBindingsPtr.

    protected field currentExtent type: UInt32x2.
    protected field renderingCommandQueue type: CommandQueuePtr.
    protected field commandListAllocator type: CommandListAllocatorPtr.
    protected field commandList type: CommandListPtr.
    protected field stateTracker type: StateTrackerPtr.

    protected field colorBufferTextureHandle type: StrongTextureHandlePtr.
    protected field framebuffer type: FramebufferPtr.
    protected field renderPass type: RenderPassPtr.

    const inline method engine => EnginePtr
        := sceneRenderingPipeline _ engine.

    method initializeWithSceneRenderingPipeline: (theRenderingPipeline: ForwardSceneRenderingPipelinePtr) ::=> Void := {
        sceneRenderingPipeline := theRenderingPipeline.
    }.

    override method mainColorBufferTextureHandle => StrongTextureHandlePtr
        := colorBufferTextureHandle.

    override method extent: (requiredExtent: UInt32x2) ::=> Void := {
        currentExtent = requiredExtent && colorBufferTextureHandle isNotNil ifTrue: {return: void}.

        let device := self engine _ renderingDevice.
        renderingCommandQueue ifNotNil: {
            renderingCommandQueue _ waitForIdle
        }.

        colorBufferTextureHandle reset.
        framebuffer reset.

        ## Create the main framebuffer.
        {
            let colorBuffer := device _ createTexture: (TextureDescription()
                type: TextureType Texture2D;
                width: requiredExtent x;
                height: requiredExtent y;
                depth: 1;
                layers: 1;
                miplevels: 1;
                format: PixelFormat B8G8R8A8_UNormSRGB;
                usageModes: TextureUsageMode Sampled | TextureUsageMode ColorAttachment;
                mainUsageMode: TextureUsageMode Sampled;
                heapType: MemoryHeapType DeviceLocal;
                sampleCount: 1;
                yourself).
            let colorBufferTextureView := colorBuffer _ getOrCreateFullView.

            colorBufferTextureHandle := device _ createScene2DBuilder _
                createTextureHandleFor: (colorBuffer upCastFor: Stdn SharedObject) view: (colorBufferTextureView upCastFor: Stdn SharedObject).

            let depthBuffer := device _ createTexture: (TextureDescription()
                type: TextureType Texture2D;
                width: requiredExtent x;
                height: requiredExtent y;
                depth: 1;
                layers: 1;
                miplevels: 1;
                format: PixelFormat D32_Float;
                usageModes: TextureUsageMode DepthAttachment;
                mainUsageMode: TextureUsageMode DepthAttachment;
                heapType: MemoryHeapType DeviceLocal;
                sampleCount: 1;
                yourself).
            let depthBufferTextureView := depthBuffer _ getOrCreateFullView.

            let colorAttachments mutable := TextureViewPtr array(colorBufferTextureView).
            framebuffer := device _ createFramebuffer: UInt32x2(640, 480) colorViews: colorAttachments depthStencilView: depthBufferTextureView.
        }.

        renderPass ifNil: {
            let colorAttachments mutable := RenderPassColorAttachmentDescription array (
                RenderPassColorAttachmentDescription()
                    format: PixelFormat B8G8R8A8_UNormSRGB;
                    beginAction: RenderPassAttachmentAction Clear;
                    endAction: RenderPassAttachmentAction Keep;
                    yourself
            ).

            let depthStencilAttachment mutable := RenderPassDepthStencilAttachmentDescription()
                format: PixelFormat D32_Float;
                beginAction: RenderPassAttachmentAction Clear;
                endAction: RenderPassAttachmentAction Discard;
                yourself.
            renderPass := device _ createRenderPass: colorAttachments depthStencilAttachment: depthStencilAttachment address.
        }.

        ## Create the camera state buffer and binding.
        cameraStateBuffer ifNil: {
            cameraStateBuffer := device _ createBuffer: (BufferDescription()
                size: (Woden Shaders CameraStateData instanceSize alignedTo: 256);
                heapType: MemoryHeapType HostToDevice;
                usageModes: BufferUsageMode Uniform;
                mainUsageMode: BufferUsageMode Uniform;
                mappingFlags: BufferMappingFlags DynamicStorage;
                yourself
            ) initialData: nil.

            cameraStateBinding := sceneRenderingPipeline _ shaderSignature _ createShaderResourceBindings: 1.
            cameraStateBinding _ bindOn: 0 uniformBuffer: cameraStateBuffer.
        }.

        ## Create the lighting state buffer and binding.
        lightingStateBuffer ifNil: {
            lightingStateBuffer := device _ createBuffer: (BufferDescription()
                size: (Woden Shaders GlobalLightingStateData instanceSize alignedTo: 256);
                heapType: MemoryHeapType HostToDevice;
                usageModes: BufferUsageMode Uniform;
                mainUsageMode: BufferUsageMode Uniform;
                mappingFlags: BufferMappingFlags DynamicStorage;
                yourself
            ) initialData: nil.

            lightingStateBinding := sceneRenderingPipeline _ shaderSignature _ createShaderResourceBindings: 2.
            lightingStateBinding _ bindOn: 0 uniformBuffer: lightingStateBuffer.
        }.

        ## Get the rendering command queue.
        renderingCommandQueue := device _ getDefaultCommandQueue.

        ## Build the command allocator and list.
        commandListAllocator ifNil: {
            commandListAllocator := device _ createCommandAllocatorOfType: CommandListType Direct for: renderingCommandQueue.
            commandList := device _ createCommandListOfType: CommandListType Direct for: commandListAllocator.
            commandList _ close.
        }.

        {
            let theStateTracker := GenericStateTracker sharedNew.
            theStateTracker _
                commandList: commandList;
                shaderCache: device _ getDefaultShaderCache;
                pipelineStateCache: device _ getDefaultPipelineStateCache.
            stateTracker := theStateTracker upCastFor: StateTracker
        }.

        currentExtent := requiredExtent.
    }.

    method uploadCameraState => Void := {
        camera ifNil: {return: void}.

        let cameraTransform := camera _ globalTransform.

        let screenSize := (currentExtent castTo: Float32x2).
        let aspect := screenSize x / screenSize y.
        let projectionMatrix := Float32x4x4 reversePerspectiveFovY: 60.0f aspect: aspect near: 0.1f far: 100.0f invertedY: self engine _ renderingDevice _ shouldInvertProjectionY.

        let cameraState mutable := Woden Shaders CameraStateData()
            matrix: cameraTransform matrix4;
            inverseMatrix: cameraTransform inverseMatrix4;

            projectionMatrix: projectionMatrix;
            inverseProjectionMatrix: projectionMatrix inverse;

            screenSize: screenSize;
            inverseScreenSize: 1 / screenSize;

            exposure: 1;
            yourself.

        cameraStateBuffer _ uploadAt: 0 size: Woden Shaders CameraStateData instanceSize data: cameraState address.
    }.

    method renderSpatialObjectNode: (objectNode: SpatialObjectNode pointer) ::=> Void := {
        let renderable := objectNode _ renderable.
        renderable ifNotNil: {
            renderable _ renderWithStateTracker: stateTracker _.
        }
    }.

    method renderSceneNodes => Void := {
        let scene := sceneRenderingPipeline _ scene.
        camera ifNil: {return: void}.
        scene ifNil: {return: void}.

        scene _ allNodesDo: {:(SceneNode ref)each :: Void |
            each isSpatialObjectNode ifTrue: {
                self renderSpatialObjectNode: (each address castTo: SpatialObjectNode pointer)
            }
        }.
    }.

    override method render => Void := {
        self uploadCameraState.

        let scene := sceneRenderingPipeline _ scene.
        scene ifNotNil: {
            renderPass _ setColorAttachment: 0 clearValue: scene _ backgroundColor.
        }.

        commandListAllocator _ resetAllocator.
        stateTracker _
            resetFor: commandListAllocator;
			useShaderSignature: sceneRenderingPipeline _ shaderSignature;
            useGraphicShaderBindings: sceneRenderingPipeline _ samplingStateBinding;
            useGraphicShaderBindings: cameraStateBinding;
            useGraphicShaderBindings: lightingStateBinding;

            frontFaceOrientation: FrontFaceOrientation CounterClockwise;
    		faceCullingMode: FaceCullingMode Back;
            depthTestingEnabled: true;
            depthWriteMask: true;
            depthFunction: CompareFunction GreaterOrEqual;

            vertexShader: Woden Shaders MetallicRoughnessMaterialShaders vertex shaderEntryPointInfo address;
            fragmentShader: Woden Shaders MetallicRoughnessMaterialShaders fragment shaderEntryPointInfo address;

            beginRenderPass: renderPass on: framebuffer contentOnBundle: false;
    		setViewport: (RectangleI32 min: Int32x2 zeros max: (currentExtent castTo: Int32x2));
    		setScissor: (RectangleI32 min: Int32x2 zeros max: (currentExtent castTo: Int32x2)).

        self renderSceneNodes.

        stateTracker _
            endRenderPass;
            close.

        renderingCommandQueue _
            submitCommandList: commandList;
            waitForIdle.
    }.
}.

}. ## End of namespace ForwardRenderer
}. ## End of namespace Woden
