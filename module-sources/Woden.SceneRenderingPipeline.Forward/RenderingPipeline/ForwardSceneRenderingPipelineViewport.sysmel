namespace Woden definition: {
namespace ForwardRenderer definition: {

useNamespace: Woden Runtime.
useNamespace: Stdn Graphics Core.
useNamespace: Stdn Graphics GUI.
useNamespace: Stdn Math Geometry.
useNamespace: Stdn Math LinearAlgebra.

#**
 * An abstract pipeline for rendering a null scene.
 *#
class ForwardSceneRenderingPipelineViewport superclass: SceneRenderingPipelineViewport; definition: {
    compileTime constant ShadowMapTextureLayers := ForwardSceneRenderingPipeline ShadowMapTextureLayers.

    public field leftEyeViewport type: ForwardSceneRenderingPipelineViewportEye.
    public field rightEyeViewport type: ForwardSceneRenderingPipelineViewportEye.
    public field sceneRenderingPipeline type: ForwardSceneRenderingPipelinePtr.

    public field currentExtent type: UInt32x2.
    public field renderingCommandQueue type: CommandQueuePtr.
    public field stateTrackers type: FrameBufferedStateTracker.

    public field depthNormalFramebuffer type: FramebufferPtr.
    public field depthNormalRenderPass type: RenderPassPtr.
    public field depthBufferTextureView type: TextureViewPtr.

    public field ssaoTextureExtent type: UInt32x2.
    public field ssaoTextureView type: TextureViewPtr.
    public field ssaoFramebuffer type: FramebufferPtr.
    public field ssaoPingTextureView type: TextureViewPtr.
    public field ssaoPingFramebuffer type: FramebufferPtr.
    public field ssaoComputationRenderPass type: RenderPassPtr.
    public field ssaoComputationBinding type: ShaderResourceBindingsPtr.
    public field ssaoBlurPingBinding type: ShaderResourceBindingsPtr.
    public field ssaoBlurPongBinding type: ShaderResourceBindingsPtr.

    public field hdrColorFramebuffer type: FramebufferPtr.
    public field hdrColorRenderPass type: RenderPassPtr.
    public field hdrColorBufferBinding type: ShaderResourceBindingsPtr.

    protected field leftEyeFramebuffer type: FramebufferPtr.
    protected field leftEyeTexture type: TextureViewPtr.
    protected field rightEyeFramebuffer type: FramebufferPtr.
    protected field rightEyeTexture type: TextureViewPtr.

    protected field eyeCompositionRenderPass type: RenderPassPtr.
    protected field stereoEyeCompositionBinding type: ShaderResourceBindingsPtr.

    protected field currentBackBufferLeftEye type: FramebufferPtr.
    protected field currentBackBufferRightEye type: FramebufferPtr.
    public field currentDisplayRenderPass type: RenderPassPtr.
    public field currentScene2D type: Stdn Graphics Scene2D NodePtr.

    const inline method engine => EnginePtr
        := sceneRenderingPipeline _ engine.

    method initializeWithSceneRenderingPipeline: (theRenderingPipeline: ForwardSceneRenderingPipelinePtr) ::=> Void := {
        sceneRenderingPipeline := theRenderingPipeline.
        leftEyeViewport viewport: self address.
        rightEyeViewport viewport: self address; isRightEye: true.
    }.

    override method extent: (requiredExtent: UInt32x2) ::=> Void := {
        currentExtent = requiredExtent && hdrColorFramebuffer isNotNil ifTrue: {return: void}.

        let device := self engine _ renderingDevice.
        renderingCommandQueue ifNotNil: {
            renderingCommandQueue _ waitForIdle
        }.

        hdrColorFramebuffer reset.

        let depthBuffer := device _ createTexture: (TextureDescription()
            type: TextureType Texture2D;
            width: requiredExtent x;
            height: requiredExtent y;
            depth: 1;
            layers: 1;
            miplevels: 1;
            format: PixelFormat R32_Typeless;
            usageModes: TextureUsageMode Sampled | TextureUsageMode DepthAttachment;
            mainUsageMode: TextureUsageMode Sampled;
            heapType: MemoryHeapType DeviceLocal;
            sampleCount: 1;
            yourself).
        let normalBuffer := device _ createTexture: (TextureDescription()
            type: TextureType Texture2D;
            width: requiredExtent x;
            height: requiredExtent y;
            depth: 1;
            layers: 1;
            miplevels: 1;
            format: PixelFormat R10G10B10A2_UNorm;
            usageModes: TextureUsageMode Sampled | TextureUsageMode ColorAttachment;
            mainUsageMode: TextureUsageMode Sampled;
            heapType: MemoryHeapType DeviceLocal;
            sampleCount: 1;
            yourself).

        let depthBufferAttachmentViewDescription  mutable := depthBuffer _ getFullViewDescription.
        depthBufferAttachmentViewDescription format: PixelFormat D32_Float.
        let depthBufferAttachmentView := depthBuffer _ createView: depthBufferAttachmentViewDescription.

        let depthBufferTextureViewDescription  mutable := depthBuffer _ getFullViewDescription.
        depthBufferTextureViewDescription format: PixelFormat R32_Float.
        depthBufferTextureView := depthBuffer _ createView: depthBufferTextureViewDescription.

        let normalBufferTextureView := normalBuffer _ getOrCreateFullView.

        ## Create the depth normal framebuffer.
        {
            let colorAttachments mutable := TextureViewPtr array(normalBufferTextureView).
            depthNormalFramebuffer := device _ createFramebuffer: requiredExtent colorViews: colorAttachments depthStencilView: depthBufferAttachmentView.
        }.

        depthNormalRenderPass ifNil: {
            let colorAttachments mutable := RenderPassColorAttachmentDescription array (
                RenderPassColorAttachmentDescription()
                    format: PixelFormat R10G10B10A2_UNorm;
                    beginAction: RenderPassAttachmentAction Clear;
                    endAction: RenderPassAttachmentAction Keep;
                    clearValue: Float32x4(0.5f, 0.5f, 1.0f, 0.0f);
                    yourself
            ).

            let depthStencilAttachment mutable := RenderPassDepthStencilAttachmentDescription()
                format: PixelFormat D32_Float;
                beginAction: RenderPassAttachmentAction Clear;
                endAction: RenderPassAttachmentAction Keep;
                yourself.
            depthNormalRenderPass := device _ createRenderPass: colorAttachments depthStencilAttachment: depthStencilAttachment address.
        }.

        ssaoComputationBinding ifNil: {
            ssaoComputationBinding := sceneRenderingPipeline _ shaderSignature _ createShaderResourceBindings: 5.
        }.
        ssaoComputationBinding _
            bindOn: 1 sampledTextureView: depthBufferTextureView;
            bindOn: 2 sampledTextureView: normalBufferTextureView.

        ## Create the SSAO computation framebuffer.
        ssaoTextureExtent := requiredExtent / 2 max: UInt32x2(4, 4).
        ##ssaoTextureExtent := requiredExtent max: UInt32x2(4, 4).
        {
            let ssaoTexture := device _ createTexture: (TextureDescription()
                type: TextureType Texture2D;
                width: ssaoTextureExtent x;
                height: ssaoTextureExtent y;
                depth: 1;
                layers: 1;
                miplevels: 1;
                format: PixelFormat R8_UNorm;
                usageModes: TextureUsageMode Sampled | TextureUsageMode ColorAttachment;
                mainUsageMode: TextureUsageMode Sampled;
                heapType: MemoryHeapType DeviceLocal;
                sampleCount: 1;
                yourself).
            ssaoTextureView := ssaoTexture _ getOrCreateFullView.

            let colorAttachments mutable := TextureViewPtr array(ssaoTextureView).
            ssaoFramebuffer := device _ createFramebuffer: ssaoTextureExtent colorViews: colorAttachments depthStencilView: TextureViewPtr nil.
        }.

        {
            let ssaoPingTexture := device _ createTexture: (TextureDescription()
                type: TextureType Texture2D;
                width: ssaoTextureExtent x;
                height: ssaoTextureExtent y;
                depth: 1;
                layers: 1;
                miplevels: 1;
                format: PixelFormat R8_UNorm;
                usageModes: TextureUsageMode Sampled | TextureUsageMode ColorAttachment;
                mainUsageMode: TextureUsageMode Sampled;
                heapType: MemoryHeapType DeviceLocal;
                sampleCount: 1;
                yourself).
            ssaoPingTextureView := ssaoPingTexture _ getOrCreateFullView.

            let colorAttachments mutable := TextureViewPtr array(ssaoPingTextureView).
            ssaoPingFramebuffer := device _ createFramebuffer: ssaoTextureExtent colorViews: colorAttachments depthStencilView: TextureViewPtr nil.
        }.

        ssaoBlurPingBinding ifNil: {
            ssaoBlurPingBinding := sceneRenderingPipeline _ shaderSignature _ createShaderResourceBindings: 5.
        }.
        ssaoBlurPingBinding _ bindOn: 1 sampledTextureView: ssaoTextureView.

        ssaoBlurPongBinding ifNil: {
            ssaoBlurPongBinding := sceneRenderingPipeline _ shaderSignature _ createShaderResourceBindings: 5.
        }.
        ssaoBlurPongBinding _ bindOn: 1 sampledTextureView: ssaoPingTextureView.

        ssaoComputationRenderPass ifNil: {
            let colorAttachments mutable := RenderPassColorAttachmentDescription array (
                RenderPassColorAttachmentDescription()
                    format: PixelFormat R8_UNorm;
                    beginAction: RenderPassAttachmentAction Keep;
                    endAction: RenderPassAttachmentAction Keep;
                    yourself
            ).

            ssaoComputationRenderPass := device _ createRenderPass: colorAttachments depthStencilAttachment: nil.
        }.

        ## Create the main hdr framebuffer.
        {
            let colorBuffer := device _ createTexture: (TextureDescription()
                type: TextureType Texture2D;
                width: requiredExtent x;
                height: requiredExtent y;
                depth: 1;
                layers: 1;
                miplevels: 1;
                format: PixelFormat R16G16B16A16_Float;
                usageModes: TextureUsageMode Sampled | TextureUsageMode ColorAttachment;
                mainUsageMode: TextureUsageMode Sampled;
                heapType: MemoryHeapType DeviceLocal;
                sampleCount: 1;
                yourself).
            let colorBufferTextureView := colorBuffer _ getOrCreateFullView.

            hdrColorBufferBinding ifNil: {
                hdrColorBufferBinding := sceneRenderingPipeline _ shaderSignature _ createShaderResourceBindings: 5.
            }.
            hdrColorBufferBinding _ bindOn: 1 sampledTextureView: colorBuffer _ getOrCreateFullView.

            let colorAttachments mutable := TextureViewPtr array(colorBufferTextureView).
            hdrColorFramebuffer := device _ createFramebuffer: requiredExtent colorViews: colorAttachments depthStencilView: depthBufferAttachmentView.
        }.

        hdrColorRenderPass ifNil: {
            let colorAttachments mutable := RenderPassColorAttachmentDescription array (
                RenderPassColorAttachmentDescription()
                    format: PixelFormat R16G16B16A16_Float;
                    beginAction: RenderPassAttachmentAction Clear;
                    endAction: RenderPassAttachmentAction Keep;
                    yourself
            ).

            let depthStencilAttachment mutable := RenderPassDepthStencilAttachmentDescription()
                format: PixelFormat D32_Float;
                beginAction: RenderPassAttachmentAction Keep;
                endAction: RenderPassAttachmentAction Keep;
                yourself.
            hdrColorRenderPass := device _ createRenderPass: colorAttachments depthStencilAttachment: depthStencilAttachment address.
        }.

        stereoPresentationMode isStereoscopic && stereoPresentationMode isMultiLayerSwapChain not ifTrue: {
            let eyeTextureDescription := TextureDescription()
                type: TextureType Texture2D;
                width: requiredExtent x;
                height: requiredExtent y;
                depth: 1;
                layers: 1;
                miplevels: 1;
                format: sceneRenderingPipeline _ swapChainColorBufferFormat;
                usageModes: TextureUsageMode Sampled | TextureUsageMode ColorAttachment;
                mainUsageMode: TextureUsageMode Sampled;
                heapType: MemoryHeapType DeviceLocal;
                sampleCount: 1;
                yourself.

            ## Left eye
            {
                let texture := device _ createTexture: eyeTextureDescription.
                leftEyeTexture := texture _ getOrCreateFullView.
                let colorAttachments mutable := TextureViewPtr array(leftEyeTexture).
                leftEyeFramebuffer := device _ createFramebuffer: requiredExtent colorViews: colorAttachments depthStencilView: TextureViewPtr nil.
            }.

            ## Right eye
            {
                let texture := device _ createTexture: eyeTextureDescription.
                rightEyeTexture := texture _ getOrCreateFullView.
                let colorAttachments mutable := TextureViewPtr array(rightEyeTexture).
                rightEyeFramebuffer := device _ createFramebuffer: requiredExtent colorViews: colorAttachments depthStencilView: TextureViewPtr nil.
            }.

            stereoEyeCompositionBinding ifNil: {
                stereoEyeCompositionBinding := sceneRenderingPipeline _ shaderSignature _ createShaderResourceBindings: 5.
            }.

            self hasStereoscopicPresentationModeWithFlippedEyes ifTrue: {
                stereoEyeCompositionBinding _ bindOn: 1 sampledTextureView: rightEyeTexture.
                stereoEyeCompositionBinding _ bindOn: 2 sampledTextureView: leftEyeTexture.
            } ifFalse: {
                stereoEyeCompositionBinding _ bindOn: 1 sampledTextureView: leftEyeTexture.
                stereoEyeCompositionBinding _ bindOn: 2 sampledTextureView: rightEyeTexture.
            }.

            eyeCompositionRenderPass ifNil: {
                let colorAttachments mutable := RenderPassColorAttachmentDescription array (
                    RenderPassColorAttachmentDescription()
                        format: sceneRenderingPipeline _ swapChainColorBufferFormat;
                        beginAction: RenderPassAttachmentAction Keep;
                        endAction: RenderPassAttachmentAction Keep;
                        yourself
                ).

                eyeCompositionRenderPass := device _ createRenderPass: colorAttachments depthStencilAttachment: nil.
            }.
        }.

        leftEyeViewport ensureResourcesAreCreatedFor: sceneRenderingPipeline owner: self address.
        stereoPresentationMode isStereoscopic ifTrue: {
            rightEyeViewport ensureResourcesAreCreatedFor: sceneRenderingPipeline owner: self address.
        }.

        ## Get the rendering command queue.
        renderingCommandQueue := device _ getDefaultCommandQueue.

        ## Build the command allocator and list.
        stateTrackers isCreated ifFalse: {
            stateTrackers for: self engine createOfType: CommandListType Direct
        }.

        currentExtent := requiredExtent.
    }.

    override method getLastFrameVisibleObjectCount => UIntPointer := {
        leftEyeViewport getLastFrameVisibleObjectCount +
            (stereoPresentationMode isMonoscopic ifTrue: 0u ifFalse: rightEyeViewport getLastFrameVisibleObjectCount)
    }.

    override method prepareRendering ::=> Void := {
        leftEyeViewport prepareRendering.
        stereoPresentationMode isStereoscopic ifTrue: {
            rightEyeViewport prepareRendering.
        }.
    }.

    method screenQuadShader => GPU ShaderEntryPointInfo const pointer := {
        self engine _ renderingDevice _ shouldInvertProjectionY ifTrue: {
            Woden Shaders CompositionMaterialShaders screenQuad shaderEntryPointInfo address
        } ifFalse: {
            Woden Shaders CompositionMaterialShaders screenQuadFlippedY shaderEntryPointInfo address
        }.
    }.

    override method setCurrentBackBufferLeftEye: (leftEye: FramebufferPtr const ref) rightEye: (rightEye: FramebufferPtr const ref) renderPass: (displayRenderPass: RenderPassPtr) ::=> Void := {
        currentDisplayRenderPass := displayRenderPass.
        currentBackBufferLeftEye := leftEye.
        currentBackBufferRightEye := rightEye.
    }.

    method hasStereoscopicPresentationModeWithFlippedEyes => Boolean8 := {
        stereoPresentationMode selectCase: #{
            StereoPresentationMode AnaglyphCyanRed : true.
            StereoPresentationMode BottomTopSideBySide : true.
            StereoPresentationMode InterleavedOddEven : true.
            _ : false.
        }.
    }.

    method stereoscopicPresentationCompositionShader => GPU ShaderEntryPointInfo const pointer := {
        stereoPresentationMode selectCase: #{
            StereoPresentationMode AnaglyphRedCyan : Woden Shaders StereoscopicCompositionMaterial anaglyphRedCyan shaderEntryPointInfo address.
            StereoPresentationMode AnaglyphCyanRed : Woden Shaders StereoscopicCompositionMaterial anaglyphRedCyan shaderEntryPointInfo address.
            StereoPresentationMode LeftRightSideBySide : Woden Shaders StereoscopicCompositionMaterial leftRightSideBySide shaderEntryPointInfo address.
            StereoPresentationMode RightLeftSideBySide : Woden Shaders StereoscopicCompositionMaterial leftRightSideBySide shaderEntryPointInfo address.
            StereoPresentationMode TopBottomSideBySide : Woden Shaders StereoscopicCompositionMaterial topBottomSideBySide shaderEntryPointInfo address.
            StereoPresentationMode BottomTopSideBySide : Woden Shaders StereoscopicCompositionMaterial topBottomSideBySide shaderEntryPointInfo address.
            StereoPresentationMode InterleavedEvenOdd : Woden Shaders StereoscopicCompositionMaterial interleavedEvenOdd shaderEntryPointInfo address.
            StereoPresentationMode InterleavedOddEven : Woden Shaders StereoscopicCompositionMaterial interleavedEvenOdd shaderEntryPointInfo address.
            StereoPresentationMode VR : Woden Shaders StereoscopicCompositionMaterial leftEyeOnly shaderEntryPointInfo address.
            _ : Woden Shaders StereoscopicCompositionMaterial leftEyeOnly shaderEntryPointInfo address.
        }.
    }.

    method composeStereoscopicPresentation => Void := {
        let viewportRectangle := RectangleI32 min: Int32x2 zeros max: (currentExtent castTo: Int32x2).
        stateTrackers current _
            resetState;
            useShaderSignature: sceneRenderingPipeline _ shaderSignature;
            useGraphicShaderBindings: sceneRenderingPipeline _ samplingStateBinding;
            useGraphicShaderBindings: stereoEyeCompositionBinding;

            beginRenderPass: currentDisplayRenderPass on: currentBackBufferLeftEye contentOnBundle: false;
            setViewport: viewportRectangle;
            setScissor: viewportRectangle;

            vertexShader: self screenQuadShader;
            fragmentShader: self stereoscopicPresentationCompositionShader;
            primitiveTopology: PrimitiveTopology Triangles;
            drawArrays: 3 instanceCount: 1 firstVertex: 0 baseInstance: 0;
            endRenderPass
    }.

    override method setScene2D: (scene2D: Stdn Graphics Scene2D NodePtr const ref) ::=> Void := {
        currentScene2D := scene2D
    }.

    override method scene2DBuilder => Stdn Graphics Scene2D BuilderPtr
        := self engine _ renderingDevice _ createScene2DBuilder.

    override method constructAndEnqueueCommandList => Void := {
        currentBackBufferLeftEye isNil || currentDisplayRenderPass isNil ifTrue: {
            return: void
        }.

        leftEyeViewport uploadRenderingStates.
        stereoPresentationMode isStereoscopic ifTrue: {
            rightEyeViewport uploadRenderingStates.
        }.

        let stateTracker := stateTrackers currentReseted.
        stereoPresentationMode isMonoscopic || stereoPresentationMode isMultiLayerSwapChain ifTrue: {
            leftEyeViewport constructCommandsOn: stateTracker displayingOn: currentBackBufferLeftEye with: currentDisplayRenderPass.
            stereoPresentationMode isMultiLayerSwapChain && currentBackBufferRightEye isNotNil ifTrue: {
                rightEyeViewport constructCommandsOn: stateTracker displayingOn: currentBackBufferRightEye with: currentDisplayRenderPass.
            }.
        } ifFalse: {
            ## Render this on separate buffers.
            leftEyeViewport constructCommandsOn: stateTracker displayingOn: leftEyeFramebuffer with: eyeCompositionRenderPass.
            rightEyeViewport constructCommandsOn: stateTracker displayingOn: rightEyeFramebuffer with: eyeCompositionRenderPass.

            self composeStereoscopicPresentation
        }.

        stateTracker _
            close.

        self engine _ enqueueCommandList: (stateTracker upCastFor: CommandList).
    }.
}.

}. ## End of namespace ForwardRenderer
}. ## End of namespace Woden
