namespace Woden definition: {
namespace ForwardRenderer definition: {

useNamespace: Woden Runtime.
useNamespace: Stdn Graphics Core.
useNamespace: Stdn Graphics GUI.
useNamespace: Stdn Math Geometry.

#**
 * An abstract pipeline for rendering a null scene.
 *#
class ForwardSceneRenderingPipelineViewport superclass: SceneRenderingPipelineViewport; definition: {
    protected field sceneRenderingPipeline type: ForwardSceneRenderingPipelinePtr.

    protected field cameraStateBuffers type: FrameBufferedBuffer.
    protected field cameraStateBindings type: FrameBufferedShaderResourcesBindings.

    protected field lightingStateBuffers type: FrameBufferedBuffer.
    protected field lightingStateBindings type: FrameBufferedShaderResourcesBindings.
    protected field lightingState type: Woden Shaders GlobalLightingStateData.

    protected field currentExtent type: UInt32x2.
    protected field renderingCommandQueue type: CommandQueuePtr.
    protected field stateTrackers type: FrameBufferedStateTracker.

    protected field colorBufferTextureHandle type: StrongTextureHandlePtr.
    protected field framebuffer type: FramebufferPtr.
    protected field renderPass type: RenderPassPtr.

    const inline method engine => EnginePtr
        := sceneRenderingPipeline _ engine.

    method initializeWithSceneRenderingPipeline: (theRenderingPipeline: ForwardSceneRenderingPipelinePtr) ::=> Void := {
        sceneRenderingPipeline := theRenderingPipeline.
    }.

    override method mainColorBufferTextureHandle => StrongTextureHandlePtr
        := colorBufferTextureHandle.

    override method extent: (requiredExtent: UInt32x2) ::=> Void := {
        currentExtent = requiredExtent && colorBufferTextureHandle isNotNil ifTrue: {return: void}.

        let device := self engine _ renderingDevice.
        renderingCommandQueue ifNotNil: {
            renderingCommandQueue _ waitForIdle
        }.

        colorBufferTextureHandle reset.
        framebuffer reset.

        ## Create the main framebuffer.
        {
            let colorBuffer := device _ createTexture: (TextureDescription()
                type: TextureType Texture2D;
                width: requiredExtent x;
                height: requiredExtent y;
                depth: 1;
                layers: 1;
                miplevels: 1;
                format: PixelFormat B8G8R8A8_UNormSRGB;
                usageModes: TextureUsageMode Sampled | TextureUsageMode ColorAttachment;
                mainUsageMode: TextureUsageMode Sampled;
                heapType: MemoryHeapType DeviceLocal;
                sampleCount: 1;
                yourself).
            let colorBufferTextureView := colorBuffer _ getOrCreateFullView.

            colorBufferTextureHandle := device _ createScene2DBuilder _
                createTextureHandleFor: (colorBuffer upCastFor: Stdn SharedObject) view: (colorBufferTextureView upCastFor: Stdn SharedObject).

            let depthBuffer := device _ createTexture: (TextureDescription()
                type: TextureType Texture2D;
                width: requiredExtent x;
                height: requiredExtent y;
                depth: 1;
                layers: 1;
                miplevels: 1;
                format: PixelFormat D32_Float;
                usageModes: TextureUsageMode DepthAttachment;
                mainUsageMode: TextureUsageMode DepthAttachment;
                heapType: MemoryHeapType DeviceLocal;
                sampleCount: 1;
                yourself).
            let depthBufferTextureView := depthBuffer _ getOrCreateFullView.

            let colorAttachments mutable := TextureViewPtr array(colorBufferTextureView).
            framebuffer := device _ createFramebuffer: UInt32x2(640, 480) colorViews: colorAttachments depthStencilView: depthBufferTextureView.
        }.

        renderPass ifNil: {
            let colorAttachments mutable := RenderPassColorAttachmentDescription array (
                RenderPassColorAttachmentDescription()
                    format: PixelFormat B8G8R8A8_UNormSRGB;
                    beginAction: RenderPassAttachmentAction Clear;
                    endAction: RenderPassAttachmentAction Keep;
                    yourself
            ).

            let depthStencilAttachment mutable := RenderPassDepthStencilAttachmentDescription()
                format: PixelFormat D32_Float;
                beginAction: RenderPassAttachmentAction Clear;
                endAction: RenderPassAttachmentAction Discard;
                yourself.
            renderPass := device _ createRenderPass: colorAttachments depthStencilAttachment: depthStencilAttachment address.
        }.

        ## Create the camera state buffer and binding.
        cameraStateBuffers isCreated ifFalse: {
            cameraStateBuffers for: self engine createWithDescription: (BufferDescription()
                size: Woden Shaders CameraStateData instanceSize;
                heapType: MemoryHeapType HostToDevice;
                usageModes: BufferUsageMode Uniform;
                mainUsageMode: BufferUsageMode Uniform;
                mappingFlags: BufferMappingFlags DynamicStorage;
                yourself
            ) initialData: nil.

            cameraStateBindings for: self engine createForShaderSignature: sceneRenderingPipeline _ shaderSignature bindingSet: 1.
            cameraStateBindings bindings doWithIndex: {:each :index :: Void |
                each _ bindOn: 0 uniformBuffer: cameraStateBuffers buffers[index]
            }.
        }.

        ## Create the lighting state buffer and binding.
        lightingStateBuffers isCreated ifFalse: {
            lightingStateBuffers for: self engine createWithDescription: (BufferDescription()
                size: Woden Shaders GlobalLightingStateData instanceSize;
                heapType: MemoryHeapType HostToDevice;
                usageModes: BufferUsageMode Uniform;
                mainUsageMode: BufferUsageMode Uniform;
                mappingFlags: BufferMappingFlags DynamicStorage;
                yourself
            ) initialData: nil.

            lightingStateBindings for: self engine createForShaderSignature: sceneRenderingPipeline _ shaderSignature bindingSet: 2.
            lightingStateBindings bindings doWithIndex: {:each :index :: Void |
                each _ bindOn: 0 uniformBuffer: lightingStateBuffers buffers[index]
            }.
        }.

        ## Get the rendering command queue.
        renderingCommandQueue := device _ getDefaultCommandQueue.

        ## Build the command allocator and list.
        stateTrackers isCreated ifFalse: {
            stateTrackers for: self engine createOfType: CommandListType Direct
        }.

        currentExtent := requiredExtent.
    }.

    method uploadCameraState => Void := {
        camera ifNil: {return: void}.

        let cameraTransform := camera _ globalTransform.

        let screenSize := (currentExtent castTo: Float32x2).
        let aspect := screenSize x / screenSize y.
        let projectionMatrix := Float32x4x4 reversePerspectiveFovY: 60.0f aspect: aspect near: 0.1f far: 100.0f invertedY: self engine _ renderingDevice _ shouldInvertProjectionY.

        let cameraState mutable := Woden Shaders CameraStateData()
            matrix: cameraTransform matrix4;
            inverseMatrix: cameraTransform inverseMatrix4;

            projectionMatrix: projectionMatrix;
            inverseProjectionMatrix: projectionMatrix inverse;

            screenSize: screenSize;
            inverseScreenSize: 1 / screenSize;

            exposure: 1;
            yourself.

        cameraStateBuffers current _ uploadAt: 0 size: Woden Shaders CameraStateData instanceSize data: cameraState address.
    }.

    method gatherSceneLightingState => Void := {
        lightingState := Woden Shaders GlobalLightingStateData().

        let scene := sceneRenderingPipeline _ scene.
        scene ifNil: {return: void}.
        camera ifNil: {return: void}.

        let viewMatrix := camera _ globalTransform inverseMatrix4.

        lightingState
            groundLighting: scene _ groundLighting;
            skyLighting: scene _ skyLighting;
            sunDirection: scene _ sunDirection.

        scene _ allNodesDo: {:(SceneNode ref)each :: Void |
            each isLightSourceNode && lightingState numberOfLights < Woden Shaders MaxNumberOfLights ifTrue: {
                let lightSourceData mutable := (each address reinterpretCastTo: LightSourceNode pointer) _ lightSourceData.
                lightSourceData
                    position: viewMatrix * lightSourceData position;
                    spotDirection: (viewMatrix * Float32x4(lightSourceData spotDirection, 0)) xyz.

                lightingState lightSources[lightingState numberOfLights] := lightSourceData.
                lightingState numberOfLights := lightingState numberOfLights + 1.
            }
        }.

    }.

    method uploadSceneLightingState => Void := {
        lightingStateBuffers current _ uploadAt: 0 size: Woden Shaders GlobalLightingStateData instanceSize data: lightingState address.
    }.

    method renderSpatialObjectNode: (objectNode: SpatialObjectNode pointer) with: (context: SceneRenderingContext ref) ::=> Void := {
        let renderable := objectNode _ renderable.
        renderable ifNotNil: {
            renderable _ renderWithContext: context.
        }
    }.

    method renderSceneNodesWith: (context: SceneRenderingContext ref) ::=> Void := {
        let scene := sceneRenderingPipeline _ scene.
        camera ifNil: {return: void}.
        scene ifNil: {return: void}.

        scene _ allNodesDo: {:(SceneNode ref)each :: Void |
            each isSpatialObjectNode ifTrue: {
                self renderSpatialObjectNode: (each address castTo: SpatialObjectNode pointer) with: context
            }
        }.
    }.

    override method render => Void := {
        self uploadCameraState.

        let scene := sceneRenderingPipeline _ scene.
        scene ifNotNil: {
            renderPass _ setColorAttachment: 0 clearValue: scene _ backgroundColor.
        }.

        let stateTracker := stateTrackers currentReseted.

        self
            gatherSceneLightingState;
            uploadSceneLightingState.

        stateTracker _
			useShaderSignature: sceneRenderingPipeline _ shaderSignature;
            useGraphicShaderBindings: sceneRenderingPipeline _ samplingStateBinding;
            useGraphicShaderBindings: cameraStateBindings current;
            useGraphicShaderBindings: lightingStateBindings current;

            frontFaceOrientation: FrontFaceOrientation CounterClockwise;
    		faceCullingMode: FaceCullingMode Back;
            depthTestingEnabled: true;
            depthWriteMask: true;
            depthFunction: CompareFunction GreaterOrEqual;

            beginRenderPass: renderPass on: framebuffer contentOnBundle: false;
    		setViewport: (RectangleI32 min: Int32x2 zeros max: (currentExtent castTo: Int32x2));
    		setScissor: (RectangleI32 min: Int32x2 zeros max: (currentExtent castTo: Int32x2)).

        let renderingContext mutable := ForwardSceneRenderingContext()
            stateTracker: stateTracker;
            sceneRenderingPipeline: sceneRenderingPipeline getPointer;
            yourself.

        self renderSceneNodesWith: renderingContext.

        stateTracker _
            endRenderPass;
            close.

        renderingCommandQueue _
            submitCommandList: (stateTracker upCastFor: CommandList).
    }.
}.

}. ## End of namespace ForwardRenderer
}. ## End of namespace Woden
