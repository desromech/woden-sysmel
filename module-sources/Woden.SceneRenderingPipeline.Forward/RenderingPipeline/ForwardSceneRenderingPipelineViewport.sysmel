namespace Woden definition: {
namespace ForwardRenderer definition: {

useNamespace: Woden Runtime.
useNamespace: Stdn Graphics Core.
useNamespace: Stdn Graphics GUI.
useNamespace: Stdn Math Geometry.
useNamespace: Stdn Math LinearAlgebra.

class ForwardSceneRenderingPipelineViewportLayer definition: {
    public field cameraState type: Woden Shaders CameraStateData.
    public field sceneRenderingPipeline type: ForwardSceneRenderingPipelinePtr.

    public field lightSources type: Stdn Collections Vector(RenderingSceneLightSourcePtr).
    public field renderableSceneObject type: Stdn Collections Vector(RenderingSceneRenderablePtr).

    public field cameraStateBuffers type: FrameBufferedBuffer.
    public field cameraStateBindings type: FrameBufferedShaderResourcesBindings.

    public field lightingStateBuffers type: FrameBufferedBuffer.
    public field lightingStateBindings type: FrameBufferedShaderResourcesBindings.
    public field lightingState type: Woden Shaders GlobalLightingStateData.

    const inline method engine => EnginePtr
        := sceneRenderingPipeline _ engine.

    method ensureResourcesAreCreatedFor: (theSceneRenderingPipeline: ForwardSceneRenderingPipelinePtr const ref) ::=> Void := {
        sceneRenderingPipeline := theSceneRenderingPipeline.

        ## Create the camera state buffer and binding.
        cameraStateBuffers isCreated ifFalse: {
            cameraStateBuffers for: self engine createWithDescription: (BufferDescription()
                size: Woden Shaders CameraStateData instanceSize;
                heapType: MemoryHeapType HostToDevice;
                usageModes: BufferUsageMode Uniform;
                mainUsageMode: BufferUsageMode Uniform;
                mappingFlags: BufferMappingFlags DynamicStorage;
                yourself
            ) initialData: nil.

            cameraStateBindings for: self engine createForShaderSignature: sceneRenderingPipeline _ shaderSignature bindingSet: 1.
            cameraStateBindings bindings doWithIndex: {:each :index :: Void |
                each _ bindOn: 0 uniformBuffer: cameraStateBuffers buffers[index]
            }.
        }.

        ## Create the lighting state buffer and binding.
        lightingStateBuffers isCreated ifFalse: {
            lightingStateBuffers for: self engine createWithDescription: (BufferDescription()
                size: Woden Shaders GlobalLightingStateData instanceSize;
                heapType: MemoryHeapType HostToDevice;
                usageModes: BufferUsageMode Uniform;
                mainUsageMode: BufferUsageMode Uniform;
                mappingFlags: BufferMappingFlags DynamicStorage;
                yourself
            ) initialData: nil.

            lightingStateBindings for: self engine createForShaderSignature: sceneRenderingPipeline _ shaderSignature bindingSet: 2.
            lightingStateBindings bindings doWithIndex: {:each :index :: Void |
                each _
                    bindOn: 0 uniformBuffer: lightingStateBuffers buffers[index];
                    bindOn: 4 sampledTextureView: sceneRenderingPipeline _ specularBRDFLutTextureView
            }.
        }.
    }.

    method cameraPostProcessingStateBuffer: (buffer: BufferPtr const ref) ::=> Void := {
        cameraStateBindings bindings do: {:each :: Void |
            each _ bindOn: 1 storageBuffer: buffer
        }.
    }.

    method gatherSceneLightingState => Void := {
        let scene := sceneRenderingPipeline _ scene.
        scene ifNil: {return: void}.

        lightingState := Woden Shaders GlobalLightingStateData().

        lightingState
            groundLighting: scene _ groundLighting;
            skyLighting: scene _ skyLighting;
            sunDirection: scene _ sunDirection.

        ## TODO: Support light probes properly.
        let blackTexture := self engine _ resourceCache _ blackTexture.
        lightingStateBindings current _
            bindOn: 5 sampledTextureWithView: blackTexture;
            bindOn: 6 sampledTextureWithView: blackTexture.

        let lightCount := lightSources size min: Woden Shaders MaxNumberOfLights.
        lightingState numberOfLights: (lightCount castTo: Int32).
        0 until: lightCount do: {:i :: Void |
            let lightSourceObject ref := lightSources[i].
            let lightSourceState mutable := lightSourceObject _ lightSourceObject _ lightState.
            lightSourceState
                position: cameraState viewMatrix * lightSourceState position;
                spotDirection: (cameraState viewMatrix * Float32x4(lightSourceState spotDirection, 0)) xyz.

            lightingState lightSources[i] := lightSourceState.
        }.
    }.

    method setSSAOTextureView: (textureView: TextureViewPtr const ref) ::=> Void := {
        lightingStateBindings current _
            bindOn: 3 sampledTextureView: textureView.
    }.

    method uploadSceneLightingState => Void := {
        lightingStateBuffers current _
            uploadAt: 0 size: Woden Shaders GlobalLightingStateData instanceSize data: lightingState address.
    }.

    method renderSceneObject: (renderObject: RenderingSceneRenderable ref) with: (context: SceneRenderingContext ref) ::=> Void := {
        renderObject spatialObject _ isGPUSpatialObject ifFalse: {return: void}.

        let spatialObject := renderObject spatialObject downCastFor: AbstractGPUSpatialObject.
        spatialObject _ objectStateBuffers isCreated ifFalse: {
            spatialObject _ objectStateBuffers for: self engine createWithDescription: (BufferDescription()
                size: Woden Shaders ObjectStateData instanceSize;
                heapType: MemoryHeapType HostToDevice;
                usageModes: BufferUsageMode Uniform;
                mainUsageMode: BufferUsageMode Uniform;
                mappingFlags: BufferMappingFlags DynamicStorage;
                yourself
            ) initialData: nil.

            spatialObject _ objectStateBindings for: self engine createForShaderSignature: sceneRenderingPipeline _ shaderSignature bindingSet: 3.
            spatialObject _ objectStateBindings bindings doWithIndex: {:each :index :: Void |
                each _ bindOn: 0 uniformBuffer: spatialObject _ objectStateBuffers buffers[index]
            }.
        }.

        spatialObject _ objectStateBuffers current _
            uploadAt: 0 size: Woden Shaders ObjectStateData instanceSize data: spatialObject _ state address.

        context stateTracker _
            useGraphicShaderBindings: spatialObject _ objectStateBindings current.

        renderObject renderable _ renderWithContext: context.
    }.

    method renderSceneObjectsWith: (context: SceneRenderingContext ref) ::=> Void := {
        context stateTracker _
            useGraphicShaderBindings: cameraStateBindings current;
            useGraphicShaderBindings: lightingStateBindings current.

        renderableSceneObject do: {:each :: Void |
            context resetObjectAttributes.
            self renderSceneObject: each _ with: context
        }.
    }.

    method uploadCameraState => Void := {
        cameraStateBuffers current _ uploadAt: 0 size: Woden Shaders CameraStateData instanceSize data: cameraState address.
    }.
}.

#**
 * An abstract pipeline for rendering a null scene.
 *#
class ForwardSceneRenderingPipelineViewport superclass: SceneRenderingPipelineViewport; definition: {
    protected field sceneRenderingPipeline type: ForwardSceneRenderingPipelinePtr.

    protected field backgroundLayer type: ForwardSceneRenderingPipelineViewportLayer.
    protected field normalLayer type: ForwardSceneRenderingPipelineViewportLayer.
    protected field foregroundLayer type: ForwardSceneRenderingPipelineViewportLayer.

    protected field currentExtent type: UInt32x2.
    protected field toneMappingOperator type: ToneMappingOperator.
    protected field renderingCommandQueue type: CommandQueuePtr.
    protected field stateTrackers type: FrameBufferedStateTracker.

    protected field cameraPostProcessingStateBuffer type: BufferPtr.
    protected field depthNormalFramebuffer type: FramebufferPtr.
    protected field depthNormalRenderPass type: RenderPassPtr.

    protected field ssaoTextureExtent type: UInt32x2.
    protected field ssaoTextureView type: TextureViewPtr.
    protected field ssaoFramebuffer type: FramebufferPtr.
    protected field ssaoComputationRenderPass type: RenderPassPtr.
    protected field ssaoComputationBinding type: ShaderResourceBindingsPtr.

    protected field hdrColorFramebuffer type: FramebufferPtr.
    protected field hdrColorRenderPass type: RenderPassPtr.
    protected field hdrColorBufferBinding type: ShaderResourceBindingsPtr.

    protected field currentBackBuffer type: FramebufferPtr.
    protected field currentDisplayRenderPass type: RenderPassPtr.
    protected field currentScene2D type: Stdn Graphics Scene2D NodePtr.

    protected field scene2DRenderers type: (StateTracker2DSceneRendererPtr array: FrameBufferingCount).

    const inline method engine => EnginePtr
        := sceneRenderingPipeline _ engine.

    method initializeWithSceneRenderingPipeline: (theRenderingPipeline: ForwardSceneRenderingPipelinePtr) ::=> Void := {
        sceneRenderingPipeline := theRenderingPipeline.
    }.

    override method extent: (requiredExtent: UInt32x2) ::=> Void := {
        currentExtent = requiredExtent && hdrColorFramebuffer isNotNil ifTrue: {return: void}.

        let device := self engine _ renderingDevice.
        renderingCommandQueue ifNotNil: {
            renderingCommandQueue _ waitForIdle
        }.

        hdrColorFramebuffer reset.

        let depthBuffer := device _ createTexture: (TextureDescription()
            type: TextureType Texture2D;
            width: requiredExtent x;
            height: requiredExtent y;
            depth: 1;
            layers: 1;
            miplevels: 1;
            format: PixelFormat D32_Float;
            usageModes: TextureUsageMode Sampled | TextureUsageMode DepthAttachment;
            mainUsageMode: TextureUsageMode Sampled;
            heapType: MemoryHeapType DeviceLocal;
            sampleCount: 1;
            yourself).
        let normalBuffer := device _ createTexture: (TextureDescription()
            type: TextureType Texture2D;
            width: requiredExtent x;
            height: requiredExtent y;
            depth: 1;
            layers: 1;
            miplevels: 1;
            format: PixelFormat R10G10B10A2_UNorm;
            usageModes: TextureUsageMode Sampled | TextureUsageMode ColorAttachment;
            mainUsageMode: TextureUsageMode Sampled;
            heapType: MemoryHeapType DeviceLocal;
            sampleCount: 1;
            yourself).

        let depthBufferTextureView := depthBuffer _ getOrCreateFullView.
        let normalBufferTextureView := normalBuffer _ getOrCreateFullView.

        ## Create the depth normal framebuffer.
        {
            let colorAttachments mutable := TextureViewPtr array(normalBufferTextureView).
            depthNormalFramebuffer := device _ createFramebuffer: requiredExtent colorViews: colorAttachments depthStencilView: depthBufferTextureView.
        }.

        depthNormalRenderPass ifNil: {
            let colorAttachments mutable := RenderPassColorAttachmentDescription array (
                RenderPassColorAttachmentDescription()
                    format: PixelFormat R10G10B10A2_UNorm;
                    beginAction: RenderPassAttachmentAction Clear;
                    endAction: RenderPassAttachmentAction Keep;
                    clearValue: Float32x4(0.5f, 0.5f, 1.0f, 0.0f);
                    yourself
            ).

            let depthStencilAttachment mutable := RenderPassDepthStencilAttachmentDescription()
                format: PixelFormat D32_Float;
                beginAction: RenderPassAttachmentAction Clear;
                endAction: RenderPassAttachmentAction Keep;
                yourself.
            depthNormalRenderPass := device _ createRenderPass: colorAttachments depthStencilAttachment: depthStencilAttachment address.
        }.

        ssaoComputationBinding ifNil: {
            ssaoComputationBinding := sceneRenderingPipeline _ shaderSignature _ createShaderResourceBindings: 5.
        }.
        ssaoComputationBinding _
            bindOn: 1 sampledTextureView: depthBufferTextureView;
            bindOn: 2 sampledTextureView: normalBufferTextureView.

        ## Create the SSAO computation framebuffer.
        ssaoTextureExtent := requiredExtent / 2 max: UInt32x2(4, 4).
        ##ssaoTextureExtent := requiredExtent max: UInt32x2(4, 4).
        {
            let ssaoTexture := device _ createTexture: (TextureDescription()
                type: TextureType Texture2D;
                width: ssaoTextureExtent x;
                height: ssaoTextureExtent y;
                depth: 1;
                layers: 1;
                miplevels: 1;
                format: PixelFormat R8_UNorm;
                usageModes: TextureUsageMode Sampled | TextureUsageMode ColorAttachment;
                mainUsageMode: TextureUsageMode Sampled;
                heapType: MemoryHeapType DeviceLocal;
                sampleCount: 1;
                yourself).
            ssaoTextureView := ssaoTexture _ getOrCreateFullView.

            let colorAttachments mutable := TextureViewPtr array(ssaoTextureView).
            ssaoFramebuffer := device _ createFramebuffer: ssaoTextureExtent colorViews: colorAttachments depthStencilView: TextureViewPtr nil.
        }.

        ssaoComputationRenderPass ifNil: {
            let colorAttachments mutable := RenderPassColorAttachmentDescription array (
                RenderPassColorAttachmentDescription()
                    format: PixelFormat R8_UNorm;
                    beginAction: RenderPassAttachmentAction Keep;
                    endAction: RenderPassAttachmentAction Keep;
                    yourself
            ).

            ssaoComputationRenderPass := device _ createRenderPass: colorAttachments depthStencilAttachment: nil.
        }.

        ## Create the main hdr framebuffer.
        {
            let colorBuffer := device _ createTexture: (TextureDescription()
                type: TextureType Texture2D;
                width: requiredExtent x;
                height: requiredExtent y;
                depth: 1;
                layers: 1;
                miplevels: 1;
                format: PixelFormat R16G16B16A16_Float;
                usageModes: TextureUsageMode Sampled | TextureUsageMode ColorAttachment;
                mainUsageMode: TextureUsageMode Sampled;
                heapType: MemoryHeapType DeviceLocal;
                sampleCount: 1;
                yourself).
            let colorBufferTextureView := colorBuffer _ getOrCreateFullView.

            hdrColorBufferBinding ifNil: {
                hdrColorBufferBinding := sceneRenderingPipeline _ shaderSignature _ createShaderResourceBindings: 5.
            }.
            hdrColorBufferBinding _ bindOn: 1 sampledTextureView: colorBuffer _ getOrCreateFullView.

            let colorAttachments mutable := TextureViewPtr array(colorBufferTextureView).
            hdrColorFramebuffer := device _ createFramebuffer: requiredExtent colorViews: colorAttachments depthStencilView: depthBufferTextureView.
        }.

        hdrColorRenderPass ifNil: {
            let colorAttachments mutable := RenderPassColorAttachmentDescription array (
                RenderPassColorAttachmentDescription()
                    format: PixelFormat R16G16B16A16_Float;
                    beginAction: RenderPassAttachmentAction Clear;
                    endAction: RenderPassAttachmentAction Keep;
                    yourself
            ).

            let depthStencilAttachment mutable := RenderPassDepthStencilAttachmentDescription()
                format: PixelFormat D32_Float;
                beginAction: RenderPassAttachmentAction Keep;
                endAction: RenderPassAttachmentAction Keep;
                yourself.
            hdrColorRenderPass := device _ createRenderPass: colorAttachments depthStencilAttachment: depthStencilAttachment address.
        }.

        cameraPostProcessingStateBuffer ifNil: {
            let initialState mutable := Woden Shaders CameraPostProcessingStateData()
                currentAverageLuminance: 0.5f;
                yourself.

            cameraPostProcessingStateBuffer := device _ createBuffer: (BufferDescription()
                size: Woden Shaders CameraPostProcessingStateData instanceSize;
                heapType: MemoryHeapType DeviceLocal;
                usageModes: BufferUsageMode Storage | BufferUsageMode CopyDestinationBuffer;
                mainUsageMode: BufferUsageMode Storage;
                mappingFlags: BufferMappingFlags DynamicStorage;
                yourself) initialData: initialState address.
        }.

        backgroundLayer
            ensureResourcesAreCreatedFor: sceneRenderingPipeline;
            cameraPostProcessingStateBuffer: cameraPostProcessingStateBuffer.
        normalLayer
            ensureResourcesAreCreatedFor: sceneRenderingPipeline;
            cameraPostProcessingStateBuffer: cameraPostProcessingStateBuffer.
        foregroundLayer
            ensureResourcesAreCreatedFor: sceneRenderingPipeline;
            cameraPostProcessingStateBuffer: cameraPostProcessingStateBuffer.

        ## Get the rendering command queue.
        renderingCommandQueue := device _ getDefaultCommandQueue.

        ## Build the command allocator and list.
        stateTrackers isCreated ifFalse: {
            stateTrackers for: self engine createOfType: CommandListType Direct
        }.

        currentExtent := requiredExtent.
    }.

    method uploadCameraState => Void := {
        let scene := sceneRenderingPipeline _ scene.
        scene ifNil: {return: void}.
        camera ifNil: {return: void}.

        toneMappingOperator := camera _ toneMappingOperator.

        let normalCameraTransform := camera _ globalTransform.
        let backgroundCameraTransform mutable := normalCameraTransform.
        backgroundCameraTransform translation: Float32x3 zeros.
        let foregroundCameraTransform := ReversibleAffineTransform3dF32 identity.

        let screenSize := (currentExtent castTo: Float32x2).
        let aspect := screenSize x / screenSize y.
        let projectionMatrix := Float32x4x4 reversePerspectiveFovY: 60.0f aspect: aspect near: 0.1f far: 100.0f invertedY: self engine _ renderingDevice _ shouldInvertProjectionY.

        let normalCameraState mutable := Woden Shaders CameraStateData()
            matrix: normalCameraTransform matrix4;
            inverseMatrix: normalCameraTransform inverseMatrix4;

            projectionMatrix: projectionMatrix;
            inverseProjectionMatrix: projectionMatrix inverse;

            screenSize: screenSize;
            inverseScreenSize: 1 / screenSize;

            currentTime: scene _ currentTime;
            currentFrameDeltaTime: 1.0f/60.0f; ## TODO: Compute this properly

            exposure: camera _ exposure;
            autoExposureInfluenceFactor: camera _ autoExposureInfluenceFactor;
            yourself.

        let backgroundCameraState mutable := normalCameraState.
        backgroundCameraState
            matrix: backgroundCameraTransform matrix4;
            inverseMatrix: backgroundCameraTransform inverseMatrix4.

        let foregroundCameraState mutable := normalCameraState.
        foregroundCameraState
            matrix: foregroundCameraTransform matrix4;
            inverseMatrix: foregroundCameraTransform inverseMatrix4.

        backgroundLayer
            cameraState: backgroundCameraState;
            uploadCameraState.
        normalLayer
            cameraState: normalCameraState;
            uploadCameraState.
        foregroundLayer
            cameraState: foregroundCameraState;
            uploadCameraState.
    }.

    method gatherVisibleRenderingObjectsOf: (sceneLayer: SceneLayerPtr const ref) on: (viewportLayer: ForwardSceneRenderingPipelineViewportLayer ref) ::=> Void := {
        let scene := sceneRenderingPipeline _ scene.
        scene ifNil: {return: void}.

        viewportLayer lightSources removeAll.
        viewportLayer renderableSceneObject removeAll.

        sceneLayer _ renderingSceneObjectsDo: {:(RenderingSceneObjectPtr const ref)each :: Void |
            each _ isRenderable ifTrue: {
                viewportLayer lightSources add: (each downCastFor: RenderingSceneLightSource)
            }.

            each _ isLightSource ifTrue: {
                viewportLayer renderableSceneObject add: (each downCastFor: RenderingSceneRenderable)
            }.
        }.
    }.

    method prepareSceneLayer: (sceneLayer: SceneLayerPtr const ref) on: (viewportLayer: ForwardSceneRenderingPipelineViewportLayer ref) ::=> Void := {
        self gatherVisibleRenderingObjectsOf: sceneLayer on: viewportLayer.

        viewportLayer
            gatherSceneLightingState;
            setSSAOTextureView: ssaoTextureView;
            uploadSceneLightingState.
    }.

    method setupStateTracker: (stateTracker: StateTrackerPtr const ref) forRenderPass: (renderPass: RenderPassPtr const ref) on: (framebuffer: FramebufferPtr const ref) ::=> Void := {
        stateTracker _
            resetState;
            useShaderSignature: sceneRenderingPipeline _ shaderSignature;
            useGraphicShaderBindings: sceneRenderingPipeline _ samplingStateBinding;

            frontFaceOrientation: FrontFaceOrientation CounterClockwise;
            depthFunction: CompareFunction GreaterOrEqual;

            beginRenderPass: renderPass on: framebuffer contentOnBundle: false;
            setViewport: (RectangleI32 min: Int32x2 zeros max: (currentExtent castTo: Int32x2));
            setScissor: (RectangleI32 min: Int32x2 zeros max: (currentExtent castTo: Int32x2)).
    }.

    method renderSceneObjectsWith: (renderingContext: SceneRenderingContext ref) ::=> Void := {
        backgroundLayer renderSceneObjectsWith: renderingContext.
        normalLayer renderSceneObjectsWith: renderingContext.
        foregroundLayer renderSceneObjectsWith: renderingContext.
    }.

    method renderDepthNormalPass => Void := {
        let stateTracker := stateTrackers current.

        self setupStateTracker: stateTracker forRenderPass: depthNormalRenderPass on: depthNormalFramebuffer.

        let renderingContext mutable := ForwardSceneRenderingContext().
        renderingContext
            stateTracker: stateTracker;
            renderPass: SceneRenderPass DepthNormal;
            sceneRenderingPipeline: sceneRenderingPipeline getPointer;
            sceneBlendingEquation: BlendingMode Copy asBlendingEquation;
            sceneFaceCullingMode: FaceCullingMode Back;
            sceneDepthTestingEnabled: OverrideableBoolean True;
            sceneDepthWriteMask: OverrideableBoolean True.

        self renderSceneObjectsWith: renderingContext.

        stateTracker _
            endRenderPass.
    }.

    method computeScreenSpaceAmbientOcclusion => Void := {
        let stateTracker := stateTrackers current.

        stateTracker _
            resetState;

            useShaderSignature: sceneRenderingPipeline _ shaderSignature;
            useGraphicShaderBindings: sceneRenderingPipeline _ samplingStateBinding;
            useGraphicShaderBindings: normalLayer cameraStateBindings current;
            useGraphicShaderBindings: ssaoComputationBinding;

            beginRenderPass: ssaoComputationRenderPass on: ssaoFramebuffer contentOnBundle: false;
            setViewport: (RectangleI32 min: Int32x2 zeros max: (ssaoTextureExtent castTo: Int32x2));
            setScissor: (RectangleI32 min: Int32x2 zeros max: (ssaoTextureExtent castTo: Int32x2));

            vertexShader: self screenQuadShader;
            fragmentShader: Woden Shaders SSAOComputationMaterialShaders ssaoComputation shaderEntryPointInfo address;
            primitiveTopology: PrimitiveTopology Triangles;
            drawArrays: 3 instanceCount: 1 firstVertex: 0 baseInstance: 0;

            endRenderPass
    }.

    method renderColorPass => Void := {
        let stateTracker := stateTrackers current.

        self setupStateTracker: stateTracker forRenderPass: hdrColorRenderPass on: hdrColorFramebuffer.

        let renderingContext mutable := ForwardSceneRenderingContext().
        renderingContext
            stateTracker: stateTracker;
            sceneRenderingPipeline: sceneRenderingPipeline getPointer;
            sceneBlendingEquation: BlendingMode Copy asBlendingEquation;
            sceneFaceCullingMode: FaceCullingMode Back;
            sceneDepthTestingEnabled: OverrideableBoolean True;
            sceneDepthWriteMask: OverrideableBoolean True.

        self renderSceneObjectsWith: renderingContext.

        stateTracker _
            endRenderPass.
    }.

    override method prepareRendering ::=> Void := {
        let scene := sceneRenderingPipeline _ scene.
        scene ifNil: {return: void}.

        self
            prepareSceneLayer: scene _ backgroundLayer on: backgroundLayer;
            prepareSceneLayer: scene _ normalLayer on: normalLayer;
            prepareSceneLayer: scene _ foregroundLayer on: foregroundLayer.
    }.

    method renderHDRScene => Void := {
        let scene := sceneRenderingPipeline _ scene.
        scene ifNotNil: {
            hdrColorRenderPass _ setColorAttachment: 0 clearValue: scene _ backgroundColor.
        }.

        self
            renderDepthNormalPass;
            computeScreenSpaceAmbientOcclusion;
            renderColorPass
    }.

    method screenQuadShader => GPU ShaderEntryPointInfo const pointer := {
        self engine _ renderingDevice _ shouldInvertProjectionY ifTrue: {
            Woden Shaders CompositionMaterialShaders screenQuad shaderEntryPointInfo address
        } ifFalse: {
            Woden Shaders CompositionMaterialShaders screenQuadFlippedY shaderEntryPointInfo address
        }.
    }.

    method toneMappingShader => GPU ShaderEntryPointInfo const pointer := {
        toneMappingOperator selectCase: #{
            ToneMappingOperator Linear : Woden Shaders ToneMappingMaterialShaders linear shaderEntryPointInfo address.
            ToneMappingOperator Reinhard : Woden Shaders ToneMappingMaterialShaders reinhard shaderEntryPointInfo address.
            ToneMappingOperator Exponential : Woden Shaders ToneMappingMaterialShaders exponential shaderEntryPointInfo address.
            ToneMappingOperator Filmic : Woden Shaders ToneMappingMaterialShaders filmic shaderEntryPointInfo address.
            _ : Woden Shaders ToneMappingMaterialShaders filmic shaderEntryPointInfo address.
        }.
    }.

    method computeAverageLuminance => Void := {
        camera isNil || camera _ hasNoAutoExposure ifTrue: {return: void}.

        let stateTracker := stateTrackers current.
        stateTracker _
            resetState;
            useShaderSignature: sceneRenderingPipeline _ shaderSignature;
            useGraphicShaderBindings: sceneRenderingPipeline _ samplingStateBinding;
            useGraphicShaderBindings: normalLayer cameraStateBindings current;
            useGraphicShaderBindings: hdrColorBufferBinding.

        sceneRenderingPipeline _
            performAverageLuminanceComputationWith: stateTracker.

        stateTracker _
            useComputeShaderBindings: sceneRenderingPipeline _ samplingStateBinding;
            useComputeShaderBindings: normalLayer cameraStateBindings current;
            useComputeShaderBindings: sceneRenderingPipeline _ luminanceComputationResultMaterialBindings.

        sceneRenderingPipeline _
            performCameraAutoExposureStateComputationWith: stateTracker.

        stateTracker _
            buffer: cameraPostProcessingStateBuffer offset: 0 size: Woden Shaders CameraPostProcessingStateData instanceSize
            memoryBarrierFrom: PipelineStageMask ComputeShader accesses: AccessMask ShaderWrite | AccessMask ShaderRead
                to: PipelineStageMask FragmentShader accesses: AccessMask ShaderRead
    }.

    method renderScene2DOverlay => Void := {
        currentScene2D ifNil: { return: void }.

        let scene2DRenderer ref := scene2DRenderers[self engine _ frameBufferingIndex].
        scene2DRenderer ifNil: {
            scene2DRenderer := StateTracker2DSceneRenderer sharedNew.
            scene2DRenderer _
                device: self engine _ renderingDevice.
        }.

        scene2DRenderer _
            extent: currentExtent;
            stateTracker: stateTrackers current;
            renderScene: currentScene2D.
    }.

    method toneMapAndComposeHDRScene => Void := {
        let stateTracker := stateTrackers current.
        stateTracker _
            resetState;
            useShaderSignature: sceneRenderingPipeline _ shaderSignature;
            useGraphicShaderBindings: sceneRenderingPipeline _ samplingStateBinding;
            useGraphicShaderBindings: normalLayer cameraStateBindings current;
            useGraphicShaderBindings: hdrColorBufferBinding;

            beginRenderPass: currentDisplayRenderPass on: currentBackBuffer contentOnBundle: false;
            setViewport: (RectangleI32 min: Int32x2 zeros max: (currentExtent castTo: Int32x2));
            setScissor: (RectangleI32 min: Int32x2 zeros max: (currentExtent castTo: Int32x2));

            vertexShader: self screenQuadShader;
            fragmentShader: self toneMappingShader;
            primitiveTopology: PrimitiveTopology Triangles;
            drawArrays: 3 instanceCount: 1 firstVertex: 0 baseInstance: 0.

        self renderScene2DOverlay.

        stateTracker _
            endRenderPass
    }.

    override method setCurrentBackBuffer: (backBuffer: FramebufferPtr const ref) renderPass: (displayRenderPass: RenderPassPtr) ::=> Void := {
        currentDisplayRenderPass := displayRenderPass.
        currentBackBuffer := backBuffer.
    }.

    override method setScene2D: (scene2D: Stdn Graphics Scene2D NodePtr const ref) ::=> Void := {
        currentScene2D := scene2D
    }.

    override method scene2DBuilder => Stdn Graphics Scene2D BuilderPtr
        := self engine _ renderingDevice _ createScene2DBuilder.

    override method constructAndEnqueueCommandList => Void := {
        currentBackBuffer isNil || currentDisplayRenderPass isNil ifTrue: {
            return: void
        }.

        self uploadCameraState.

        let stateTracker := stateTrackers currentReseted.
        self renderHDRScene;
            computeAverageLuminance;
            toneMapAndComposeHDRScene.

        stateTracker _
            close.

        renderingCommandQueue _
            submitCommandList: (stateTracker upCastFor: CommandList).
    }.
}.

}. ## End of namespace ForwardRenderer
}. ## End of namespace Woden
