namespace Woden definition: {
namespace ForwardRenderer definition: {

useNamespace: Woden Runtime.
useNamespace: Stdn Graphics Core.
useNamespace: Stdn Graphics GUI.
useNamespace: Stdn Math Geometry.
useNamespace: Stdn Math LinearAlgebra.

struct ViewportLayerLightSource definition: {
    public field cameraDistance type: Float32.
    public field object type: RenderingSceneLightSourcePtr.
    public field shadowMap type: ShadowMapRenderingPipelineLayer pointer.

    const method < (o: SelfType const ref) ::=> Boolean8
        := cameraDistance < o cameraDistance.
}.

struct ViewportLayerRenderableObject definition: {
    public field priority type: RenderPriority.
    public field cameraDistance type: Float32.
    public field object type: RenderingSceneRenderablePtr.

    const method < (o: SelfType const ref) ::=> Boolean8 := {
        priority = o priority ifTrue: {
            priority < RenderPriority TranslucentSorted ifTrue: {
                cameraDistance > o cameraDistance.
            } ifFalse: {
                cameraDistance < o cameraDistance.
            }
        } ifFalse: {
            priority < o priority
        }
    }
}.

class RenderingPipelineCameraLayer definition: {
    public field cameraTransform type: ReversibleAffineTransform3dF32.
    public field cameraState type: Woden Shaders CameraStateData.
    public field frustum type: FrustumF32.
    public field sceneRenderingPipeline type: ForwardSceneRenderingPipelinePtr.

    public field renderableSceneObjects type: Stdn Collections Vector(ViewportLayerRenderableObject).

    public field cameraStateBuffers type: FrameBufferedBuffer.
    public field cameraStateBindings type: FrameBufferedShaderResourcesBindings.

    const inline method engine => EnginePtr
        := sceneRenderingPipeline _ engine.

    virtual method ensureResourcesAreCreatedFor: (theSceneRenderingPipeline: ForwardSceneRenderingPipelinePtr const ref) ::=> Void := {
        sceneRenderingPipeline := theSceneRenderingPipeline.

        ## Create the camera state buffer and binding.
        cameraStateBuffers isCreated ifFalse: {
            cameraStateBuffers for: self engine createWithDescription: (BufferDescription()
                size: Woden Shaders CameraStateData instanceSize;
                heapType: MemoryHeapType HostToDevice;
                usageModes: BufferUsageMode Uniform;
                mainUsageMode: BufferUsageMode Uniform;
                mappingFlags: BufferMappingFlags DynamicStorage;
                yourself
            ) initialData: nil.

            cameraStateBindings for: self engine createForShaderSignature: sceneRenderingPipeline _ shaderSignature bindingSet: 1.
            cameraStateBindings bindings doWithIndex: {:each :index :: Void |
                each _ bindOn: 0 uniformBuffer: cameraStateBuffers buffers[index]
            }.
        }.
    }.

    method sortRenderingObjects => Void := {
        renderableSceneObjects sort
    }.

    method uploadCameraState => Void := {
        cameraStateBuffers current _ uploadAt: 0 size: Woden Shaders CameraStateData instanceSize data: cameraState address.
    }.

    method renderSceneObject: (renderObject: RenderingSceneRenderable ref) with: (context: SceneRenderingContext ref) ::=> Void := {
        renderObject spatialObject _ isGPUSpatialObject ifFalse: {return: void}.

        let spatialObject := renderObject spatialObject downCastFor: AbstractGPUSpatialObject.
        spatialObject _ objectStateBuffers isCreated ifFalse: {
            spatialObject _ objectStateBuffers for: self engine createWithDescription: (BufferDescription()
                size: Woden Shaders ObjectStateData instanceSize;
                heapType: MemoryHeapType HostToDevice;
                usageModes: BufferUsageMode Uniform;
                mainUsageMode: BufferUsageMode Uniform;
                mappingFlags: BufferMappingFlags DynamicStorage;
                yourself
            ) initialData: nil.

            spatialObject _ objectStateBindings for: self engine createForShaderSignature: sceneRenderingPipeline _ shaderSignature bindingSet: 3.
            spatialObject _ objectStateBindings bindings doWithIndex: {:each :index :: Void |
                each _ bindOn: 0 uniformBuffer: spatialObject _ objectStateBuffers buffers[index]
            }.
        }.

        spatialObject _ objectStateBuffers current _
            uploadAt: 0 size: Woden Shaders ObjectStateData instanceSize data: spatialObject _ state address.

        context stateTracker _
            useGraphicShaderBindings: spatialObject _ objectStateBindings current.

        renderObject renderable _ renderWithContext: context.
    }.

    virtual method renderSceneObjectsWith: (context: SceneRenderingContext ref) ::=> Void := {
        context stateTracker _
            useGraphicShaderBindings: cameraStateBindings current.

        renderableSceneObjects do: {:each :: Void |
            context resetObjectAttributes.
            self renderSceneObject: each object _ with: context
        }.
    }.
}.

sealed class ShadowMapRenderingPipelineLayer superclass: RenderingPipelineCameraLayer; definition: {

}.

sealed class ForwardSceneRenderingPipelineViewportLayer superclass: RenderingPipelineCameraLayer; definition: {
    public field lightSources type: Stdn Collections Vector(ViewportLayerLightSource).

    public field lightingStateBuffers type: FrameBufferedBuffer.
    public field lightingStateBindings type: FrameBufferedShaderResourcesBindings.
    public field lightingState type: Woden Shaders GlobalLightingStateData.

    const inline method layerLightSourceCount => UIntPointer
        := lightSources size min: Woden Shaders MaxNumberOfLights .

    override method ensureResourcesAreCreatedFor: (theSceneRenderingPipeline: ForwardSceneRenderingPipelinePtr const ref) ::=> Void := {
        super ensureResourcesAreCreatedFor: theSceneRenderingPipeline.

        ## Create the lighting state buffer and binding.
        lightingStateBuffers isCreated ifFalse: {
            lightingStateBuffers for: self engine createWithDescription: (BufferDescription()
                size: Woden Shaders GlobalLightingStateData instanceSize;
                heapType: MemoryHeapType HostToDevice;
                usageModes: BufferUsageMode Uniform;
                mainUsageMode: BufferUsageMode Uniform;
                mappingFlags: BufferMappingFlags DynamicStorage;
                yourself
            ) initialData: nil.

            lightingStateBindings for: self engine createForShaderSignature: sceneRenderingPipeline _ shaderSignature bindingSet: 2.
            lightingStateBindings bindings doWithIndex: {:each :index :: Void |
                each _
                    bindOn: 0 uniformBuffer: lightingStateBuffers buffers[index];
                    bindOn: 1 sampledTextureView: sceneRenderingPipeline _ shadowMapTextureView;
                    bindOn: 4 sampledTextureView: sceneRenderingPipeline _ specularBRDFLutTextureView
            }.
        }.
    }.


    method cameraPostProcessingStateBuffer: (buffer: BufferPtr const ref) ::=> Void := {
        cameraStateBindings bindings do: {:each :: Void |
            each _ bindOn: 1 storageBuffer: buffer
        }.
    }.

    method sortLights => Void := {
        lightSources sort
    }.

    method gatherSceneLightingState => Void := {
        let scene := sceneRenderingPipeline _ scene.
        scene ifNil: {return: void}.

        lightingState := Woden Shaders GlobalLightingStateData().

        lightingState
            groundLighting: Float32x4(scene _ groundLighting, 0.0f);
            skyLighting: Float32x4(scene _ skyLighting, 0.0f);
            sunDirection: scene _ sunDirection.

        ## TODO: Support light probes properly.
        let blackTexture := self engine _ resourceCache _ blackTextureCube.
        lightingStateBindings current _
            bindOn: 5 sampledTextureWithView: blackTexture;
            bindOn: 6 sampledTextureWithView: blackTexture.

        let lightCount := self layerLightSourceCount.
        lightingState numberOfLights: (lightCount castTo: Int32).
        0 until: lightCount do: {:i :: Void |
            let lightSourceObject ref := lightSources[i] object.
            let lightSourceObjectState ref := lightSourceObject _ lightSourceObject _.
            let lightSourceState mutable := lightSourceObjectState lightState.

            lightSourceState shadowMapLayer: -1.

            lightSourceState position w = 0 ifTrue: {
                lightSourceState
                    position: Float32x4((lightSourceState position * cameraState inverseViewMatrix) xyz normalized, 0);
                    spotDirection: Float32x3 zeros.
            } ifFalse: {
                lightSourceState
                    position: cameraState viewMatrix * lightSourceState position;
                    spotDirection: (Float32x4(lightSourceState spotDirection, 0) * cameraState inverseViewMatrix) xyz.
            }.

            lightingState lightSources[i] := lightSourceState.
        }.
    }.

    method setSSAOTextureView: (textureView: TextureViewPtr const ref) ::=> Void := {
        lightingStateBindings current _
            bindOn: 3 sampledTextureView: textureView.
    }.

    method uploadLightingState => Void := {
        lightingStateBuffers current _
            uploadAt: 0 size: Woden Shaders GlobalLightingStateData instanceSize data: lightingState address.
    }.

    override method renderSceneObjectsWith: (context: SceneRenderingContext ref) ::=> Void := {
        context stateTracker _
            useGraphicShaderBindings: lightingStateBindings current.

        super renderSceneObjectsWith: context
    }.
}.

#**
 * An abstract pipeline for rendering a null scene.
 *#
class ForwardSceneRenderingPipelineViewport superclass: SceneRenderingPipelineViewport; definition: {
    compileTime constant ShadowMapTextureLayers := ForwardSceneRenderingPipeline ShadowMapTextureLayers.

    protected field sceneRenderingPipeline type: ForwardSceneRenderingPipelinePtr.

    protected field backgroundLayer type: ForwardSceneRenderingPipelineViewportLayer.
    protected field normalLayer type: ForwardSceneRenderingPipelineViewportLayer.
    protected field foregroundLayer type: ForwardSceneRenderingPipelineViewportLayer.

    protected field activeShadowMapLayerCount type: UIntPointer.
    protected field shadowMapLayers type: (ShadowMapRenderingPipelineLayer array: ShadowMapTextureLayers).

    protected field currentExtent type: UInt32x2.
    protected field toneMappingOperator type: ToneMappingOperator.
    protected field renderingCommandQueue type: CommandQueuePtr.
    protected field stateTrackers type: FrameBufferedStateTracker.

    protected field cameraPostProcessingStateBuffer type: BufferPtr.
    protected field depthNormalFramebuffer type: FramebufferPtr.
    protected field depthNormalRenderPass type: RenderPassPtr.

    protected field ssaoTextureExtent type: UInt32x2.
    protected field ssaoTextureView type: TextureViewPtr.
    protected field ssaoFramebuffer type: FramebufferPtr.
    protected field ssaoComputationRenderPass type: RenderPassPtr.
    protected field ssaoComputationBinding type: ShaderResourceBindingsPtr.

    protected field hdrColorFramebuffer type: FramebufferPtr.
    protected field hdrColorRenderPass type: RenderPassPtr.
    protected field hdrColorBufferBinding type: ShaderResourceBindingsPtr.

    protected field currentBackBuffer type: FramebufferPtr.
    protected field currentDisplayRenderPass type: RenderPassPtr.
    protected field currentScene2D type: Stdn Graphics Scene2D NodePtr.

    protected field scene2DRenderers type: (StateTracker2DSceneRendererPtr array: FrameBufferingCount).

    const inline method engine => EnginePtr
        := sceneRenderingPipeline _ engine.

    method initializeWithSceneRenderingPipeline: (theRenderingPipeline: ForwardSceneRenderingPipelinePtr) ::=> Void := {
        sceneRenderingPipeline := theRenderingPipeline.
    }.

    override method extent: (requiredExtent: UInt32x2) ::=> Void := {
        currentExtent = requiredExtent && hdrColorFramebuffer isNotNil ifTrue: {return: void}.

        let device := self engine _ renderingDevice.
        renderingCommandQueue ifNotNil: {
            renderingCommandQueue _ waitForIdle
        }.

        hdrColorFramebuffer reset.

        let depthBuffer := device _ createTexture: (TextureDescription()
            type: TextureType Texture2D;
            width: requiredExtent x;
            height: requiredExtent y;
            depth: 1;
            layers: 1;
            miplevels: 1;
            format: PixelFormat D32_Float;
            usageModes: TextureUsageMode Sampled | TextureUsageMode DepthAttachment;
            mainUsageMode: TextureUsageMode Sampled;
            heapType: MemoryHeapType DeviceLocal;
            sampleCount: 1;
            yourself).
        let normalBuffer := device _ createTexture: (TextureDescription()
            type: TextureType Texture2D;
            width: requiredExtent x;
            height: requiredExtent y;
            depth: 1;
            layers: 1;
            miplevels: 1;
            format: PixelFormat R10G10B10A2_UNorm;
            usageModes: TextureUsageMode Sampled | TextureUsageMode ColorAttachment;
            mainUsageMode: TextureUsageMode Sampled;
            heapType: MemoryHeapType DeviceLocal;
            sampleCount: 1;
            yourself).

        let depthBufferTextureView := depthBuffer _ getOrCreateFullView.
        let normalBufferTextureView := normalBuffer _ getOrCreateFullView.

        ## Create the depth normal framebuffer.
        {
            let colorAttachments mutable := TextureViewPtr array(normalBufferTextureView).
            depthNormalFramebuffer := device _ createFramebuffer: requiredExtent colorViews: colorAttachments depthStencilView: depthBufferTextureView.
        }.

        depthNormalRenderPass ifNil: {
            let colorAttachments mutable := RenderPassColorAttachmentDescription array (
                RenderPassColorAttachmentDescription()
                    format: PixelFormat R10G10B10A2_UNorm;
                    beginAction: RenderPassAttachmentAction Clear;
                    endAction: RenderPassAttachmentAction Keep;
                    clearValue: Float32x4(0.5f, 0.5f, 1.0f, 0.0f);
                    yourself
            ).

            let depthStencilAttachment mutable := RenderPassDepthStencilAttachmentDescription()
                format: PixelFormat D32_Float;
                beginAction: RenderPassAttachmentAction Clear;
                endAction: RenderPassAttachmentAction Keep;
                yourself.
            depthNormalRenderPass := device _ createRenderPass: colorAttachments depthStencilAttachment: depthStencilAttachment address.
        }.

        ssaoComputationBinding ifNil: {
            ssaoComputationBinding := sceneRenderingPipeline _ shaderSignature _ createShaderResourceBindings: 5.
        }.
        ssaoComputationBinding _
            bindOn: 1 sampledTextureView: depthBufferTextureView;
            bindOn: 2 sampledTextureView: normalBufferTextureView.

        ## Create the SSAO computation framebuffer.
        ssaoTextureExtent := requiredExtent / 2 max: UInt32x2(4, 4).
        ##ssaoTextureExtent := requiredExtent max: UInt32x2(4, 4).
        {
            let ssaoTexture := device _ createTexture: (TextureDescription()
                type: TextureType Texture2D;
                width: ssaoTextureExtent x;
                height: ssaoTextureExtent y;
                depth: 1;
                layers: 1;
                miplevels: 1;
                format: PixelFormat R8_UNorm;
                usageModes: TextureUsageMode Sampled | TextureUsageMode ColorAttachment;
                mainUsageMode: TextureUsageMode Sampled;
                heapType: MemoryHeapType DeviceLocal;
                sampleCount: 1;
                yourself).
            ssaoTextureView := ssaoTexture _ getOrCreateFullView.

            let colorAttachments mutable := TextureViewPtr array(ssaoTextureView).
            ssaoFramebuffer := device _ createFramebuffer: ssaoTextureExtent colorViews: colorAttachments depthStencilView: TextureViewPtr nil.
        }.

        ssaoComputationRenderPass ifNil: {
            let colorAttachments mutable := RenderPassColorAttachmentDescription array (
                RenderPassColorAttachmentDescription()
                    format: PixelFormat R8_UNorm;
                    beginAction: RenderPassAttachmentAction Keep;
                    endAction: RenderPassAttachmentAction Keep;
                    yourself
            ).

            ssaoComputationRenderPass := device _ createRenderPass: colorAttachments depthStencilAttachment: nil.
        }.

        ## Create the main hdr framebuffer.
        {
            let colorBuffer := device _ createTexture: (TextureDescription()
                type: TextureType Texture2D;
                width: requiredExtent x;
                height: requiredExtent y;
                depth: 1;
                layers: 1;
                miplevels: 1;
                format: PixelFormat R16G16B16A16_Float;
                usageModes: TextureUsageMode Sampled | TextureUsageMode ColorAttachment;
                mainUsageMode: TextureUsageMode Sampled;
                heapType: MemoryHeapType DeviceLocal;
                sampleCount: 1;
                yourself).
            let colorBufferTextureView := colorBuffer _ getOrCreateFullView.

            hdrColorBufferBinding ifNil: {
                hdrColorBufferBinding := sceneRenderingPipeline _ shaderSignature _ createShaderResourceBindings: 5.
            }.
            hdrColorBufferBinding _ bindOn: 1 sampledTextureView: colorBuffer _ getOrCreateFullView.

            let colorAttachments mutable := TextureViewPtr array(colorBufferTextureView).
            hdrColorFramebuffer := device _ createFramebuffer: requiredExtent colorViews: colorAttachments depthStencilView: depthBufferTextureView.
        }.

        hdrColorRenderPass ifNil: {
            let colorAttachments mutable := RenderPassColorAttachmentDescription array (
                RenderPassColorAttachmentDescription()
                    format: PixelFormat R16G16B16A16_Float;
                    beginAction: RenderPassAttachmentAction Clear;
                    endAction: RenderPassAttachmentAction Keep;
                    yourself
            ).

            let depthStencilAttachment mutable := RenderPassDepthStencilAttachmentDescription()
                format: PixelFormat D32_Float;
                beginAction: RenderPassAttachmentAction Keep;
                endAction: RenderPassAttachmentAction Keep;
                yourself.
            hdrColorRenderPass := device _ createRenderPass: colorAttachments depthStencilAttachment: depthStencilAttachment address.
        }.

        cameraPostProcessingStateBuffer ifNil: {
            let initialState mutable := Woden Shaders CameraPostProcessingStateData()
                currentAverageLuminance: 0.5f;
                yourself.

            cameraPostProcessingStateBuffer := device _ createBuffer: (BufferDescription()
                size: Woden Shaders CameraPostProcessingStateData instanceSize;
                heapType: MemoryHeapType DeviceLocal;
                usageModes: BufferUsageMode Storage | BufferUsageMode CopyDestinationBuffer;
                mainUsageMode: BufferUsageMode Storage;
                mappingFlags: BufferMappingFlags DynamicStorage;
                yourself) initialData: initialState address.
        }.

        backgroundLayer
            ensureResourcesAreCreatedFor: sceneRenderingPipeline;
            cameraPostProcessingStateBuffer: cameraPostProcessingStateBuffer.
        normalLayer
            ensureResourcesAreCreatedFor: sceneRenderingPipeline;
            cameraPostProcessingStateBuffer: cameraPostProcessingStateBuffer.
        foregroundLayer
            ensureResourcesAreCreatedFor: sceneRenderingPipeline;
            cameraPostProcessingStateBuffer: cameraPostProcessingStateBuffer.

        0 until: ShadowMapTextureLayers do: {:i :: Void |
            shadowMapLayers[i]
                ensureResourcesAreCreatedFor: sceneRenderingPipeline.
        }.

        ## Get the rendering command queue.
        renderingCommandQueue := device _ getDefaultCommandQueue.

        ## Build the command allocator and list.
        stateTrackers isCreated ifFalse: {
            stateTrackers for: self engine createOfType: CommandListType Direct
        }.

        currentExtent := requiredExtent.
    }.

    method prepareCameraState => Void := {
        let scene := sceneRenderingPipeline _ scene.
        scene ifNil: {return: void}.
        camera ifNil: {return: void}.

        toneMappingOperator := camera _ toneMappingOperator.

        let normalCameraTransform := camera _ globalTransform.
        let backgroundCameraTransform mutable := normalCameraTransform.
        backgroundCameraTransform translation: Float32x3 zeros.
        let foregroundCameraTransform := ReversibleAffineTransform3dF32 identity.

        let fov := camera _ fov.
        let nearDistance := camera _ nearDistance.
        let farDistance := camera _ farDistance.

        let screenSize := (currentExtent castTo: Float32x2).
        let aspect := screenSize x / screenSize y.
        let projectionMatrix := Float32x4x4 reversePerspectiveFovY: fov aspect: aspect near: nearDistance far: farDistance invertedY: self engine _ renderingDevice _ shouldInvertProjectionY.
        let frustum := FrustumF32()
            makePerspectiveFovY: fov aspect: aspect near: nearDistance far: farDistance;
            yourself.

        let backgroundFrustum := frustum transformedWith: backgroundCameraTransform.
        let normalFrustum := frustum transformedWith: normalCameraTransform.
        let foregroundFrustum := frustum transformedWith: foregroundCameraTransform.

        let normalCameraState mutable := Woden Shaders CameraStateData()
            matrix: normalCameraTransform matrix4;
            inverseMatrix: normalCameraTransform inverseMatrix4;

            projectionMatrix: projectionMatrix;
            inverseProjectionMatrix: projectionMatrix inverse;

            screenSize: screenSize;
            inverseScreenSize: 1 / screenSize;

            currentTime: scene _ currentTime;
            currentFrameDeltaTime: 1.0f/60.0f; ## TODO: Compute this properly

            exposure: camera _ exposure;
            autoExposureInfluenceFactor: camera _ autoExposureInfluenceFactor;
            yourself.

        let backgroundCameraState mutable := normalCameraState.
        backgroundCameraState
            matrix: backgroundCameraTransform matrix4;
            inverseMatrix: backgroundCameraTransform inverseMatrix4.

        let foregroundCameraState mutable := normalCameraState.
        foregroundCameraState
            matrix: foregroundCameraTransform matrix4;
            inverseMatrix: foregroundCameraTransform inverseMatrix4.

        backgroundLayer
            cameraTransform: backgroundCameraTransform;
            cameraState: backgroundCameraState;
            frustum: backgroundFrustum.
        normalLayer
            cameraTransform: normalCameraTransform;
            cameraState: normalCameraState;
            frustum: normalFrustum.
        foregroundLayer
            cameraTransform: foregroundCameraTransform;
            cameraState: foregroundCameraState;
            frustum: foregroundFrustum.
    }.

    method uploadCameraState => Void := {
        backgroundLayer uploadCameraState.
        normalLayer uploadCameraState.
        foregroundLayer uploadCameraState.
        0 until: activeShadowMapLayerCount do: {:i :: Void |
            shadowMapLayers[i] uploadCameraState
        }.
    }.

    method uploadLightingState => Void := {
        backgroundLayer
            setSSAOTextureView: ssaoTextureView;
            uploadLightingState.
        normalLayer
            setSSAOTextureView: ssaoTextureView;
            uploadLightingState.
        foregroundLayer
            setSSAOTextureView: ssaoTextureView;
            uploadLightingState.
    }.

    method gatherVisibleRenderingObjectsOf: (sceneLayer: SceneLayerPtr const ref) on: (viewportLayer: ForwardSceneRenderingPipelineViewportLayer ref) ::=> Void := {
        let scene := sceneRenderingPipeline _ scene.
        scene ifNil: {return: void}.

        viewportLayer lightSources removeAll.
        viewportLayer renderableSceneObjects removeAll.

        let frustum ref := viewportLayer frustum.
        sceneLayer _ renderingSceneObjectsDo: {:(RenderingSceneObjectPtr const ref)each :: Void |
            let cameraDistance := (viewportLayer cameraTransform translation - each _ boundingBox center) length.

            ## TODO: Compare the light bounding box with the frustum in the case of point and spot lights.
            each _ isLightSource ifTrue: {
                viewportLayer lightSources add: (ViewportLayerLightSource()
                    cameraDistance: cameraDistance;
                    object: (each downCastFor: RenderingSceneLightSource);
                    yourself)
            }.

            each _ isRenderable && (frustum intersectsOrContainsBox: each _ boundingBox) ifTrue: {
                let renderingSceneRenderable := each downCastFor: RenderingSceneRenderable.
                viewportLayer renderableSceneObjects add: (ViewportLayerRenderableObject()
                    priority: renderingSceneRenderable _ renderable _ renderPriority;
                    cameraDistance: cameraDistance;
                    object: renderingSceneRenderable;
                    yourself)
            }.
        }.
    }.

    method gatherShadowCastingRenderingObjectsOf: (sceneLayer: SceneLayerPtr const ref) on: (viewportLayer: ShadowMapRenderingPipelineLayer ref) ::=> Void := {
        let scene := sceneRenderingPipeline _ scene.
        scene ifNil: {return: void}.

        viewportLayer renderableSceneObjects removeAll.

        let frustum ref := viewportLayer frustum.
        sceneLayer _ renderingSceneObjectsDo: {:(RenderingSceneObjectPtr const ref)each :: Void |
            let cameraDistance := (viewportLayer cameraTransform translation - each _ boundingBox center) length.

            each _ isRenderable && (frustum intersectsOrContainsBox: each _ boundingBox) ifTrue: {
                let renderingSceneRenderable := each downCastFor: RenderingSceneRenderable.
                let priority := renderingSceneRenderable _ renderable _ renderPriority.
                priority < RenderPriority TranslucentSorted ifTrue: {
                    viewportLayer renderableSceneObjects add: (ViewportLayerRenderableObject()
                        priority: priority;
                        cameraDistance: cameraDistance;
                        object: renderingSceneRenderable;
                        yourself)
                }.
            }.
        }.
    }.

    method selectAndPrepareShadowCastingSpotLight: (spotLight: ViewportLayerLightSource ref)
        lightState: (lightState: Woden Shaders LightSourceData ref)
        in: (viewportLayer: ForwardSceneRenderingPipelineViewportLayer ref) ::=> Void := {
        let scene := sceneRenderingPipeline _ scene.
        scene ifNil: {return: void}.

        let lightSourceObject := spotLight object _ lightSourceObject.

        let fov := lightSourceObject _ spotOuterCutoff.
        let nearDistance := 0.01f.
        let farDistance := lightState radius.
        let aspect := 1.0f.

        let projectionMatrix := Float32x4x4 reversePerspectiveFovY: fov aspect: aspect near: nearDistance far: farDistance invertedY: self engine _ renderingDevice _ shouldInvertProjectionY.
        let frustum := FrustumF32()
            makePerspectiveFovY: fov aspect: aspect near: nearDistance far: farDistance;
            yourself.

        let cameraTransform := spotLight object _ currentTransform.
        let worldFrustum := frustum transformedWith: cameraTransform.
        let cameraState mutable := Woden Shaders CameraStateData()
            matrix: cameraTransform matrix4;
            inverseMatrix: cameraTransform inverseMatrix4;

            projectionMatrix: projectionMatrix;
            currentTime: scene _ currentTime;
            yourself.

        let shadowLayer ref := shadowMapLayers[activeShadowMapLayerCount].
        shadowLayer
            cameraTransform: cameraTransform;
            cameraState: cameraState;
            frustum: worldFrustum.

        let shadowMapBias := self engine _ projectiveTextureMatrix.
        lightState
            cascadeSplitOffsets: 0;
            cascadeFrustumPlane: 0;
            shadowMapLayer: activeShadowMapLayerCount;
            shadowMapTransform: (shadowMapBias * (projectionMatrix * (cameraState viewMatrix * viewportLayer cameraState inverseViewMatrix))).

        activeShadowMapLayerCount := activeShadowMapLayerCount + 1
    }.

    method selectAndPrepareShadowCastingLightsIn: (viewportLayer: ForwardSceneRenderingPipelineViewportLayer ref) ::=> Void := {
        activeShadowMapLayerCount >= ShadowMapTextureLayers ifTrue: {return: void}.

        0 until: viewportLayer layerLightSourceCount do: {:i :: Void |
            let lightSource ref := viewportLayer lightSources[i].
            let lightState ref := viewportLayer lightingState lightSources[i].

            lightSource object _ castShadows ifTrue: {
                lightSource object _ lightType selectCase: #{
                LightSourceType Spot : { self selectAndPrepareShadowCastingSpotLight: lightSource lightState: lightState in: viewportLayer }.
                _ : {}
                }.

                activeShadowMapLayerCount >= ShadowMapTextureLayers ifTrue: {return: void}.
            }
        }
    }.

    method prepareShadowMapLayer: (layer: ShadowMapRenderingPipelineLayer ref) ::=> Void := {
        let scene := sceneRenderingPipeline _ scene.
        scene ifNil: {return: void}.

        self gatherShadowCastingRenderingObjectsOf: scene _ normalLayer on: layer
    }.

    method prepareShadowMapLayers => Void := {
        0 until: activeShadowMapLayerCount do: {:i :: Void |
            self prepareShadowMapLayer: shadowMapLayers[i]
        }
    }.

    method prepareSceneLayer: (sceneLayer: SceneLayerPtr const ref) on: (viewportLayer: ForwardSceneRenderingPipelineViewportLayer ref) ::=> Void := {
        self gatherVisibleRenderingObjectsOf: sceneLayer on: viewportLayer.

        viewportLayer
            sortRenderingObjects;
            sortLights;
            gatherSceneLightingState.

        viewportLayer address == normalLayer address ifTrue: {
            self selectAndPrepareShadowCastingLightsIn: viewportLayer
        }.
    }.

    method setupStateTracker: (stateTracker: StateTrackerPtr const ref) forRenderPass: (renderPass: RenderPassPtr const ref)
        on: (framebuffer: FramebufferPtr const ref) ::=> Void
        := self setupStateTracker: stateTracker forRenderPass: renderPass
            on: framebuffer viewport: (RectangleI32 min: Int32x2 zeros max: (currentExtent castTo: Int32x2)).

    method setupStateTracker: (stateTracker: StateTrackerPtr const ref) forRenderPass: (renderPass: RenderPassPtr const ref)
        on: (framebuffer: FramebufferPtr const ref) viewport: (viewport: RectangleI32) ::=> Void := {
        stateTracker _
            resetState;
            useShaderSignature: sceneRenderingPipeline _ shaderSignature;
            useGraphicShaderBindings: sceneRenderingPipeline _ samplingStateBinding;

            frontFaceOrientation: FrontFaceOrientation CounterClockwise;
            depthFunction: CompareFunction GreaterOrEqual;

            beginRenderPass: renderPass on: framebuffer contentOnBundle: false;
            setViewport: viewport;
            setScissor: viewport.
    }.

    method renderSceneObjectsWith: (renderingContext: SceneRenderingContext ref) ::=> Void := {
        backgroundLayer renderSceneObjectsWith: renderingContext.
        normalLayer renderSceneObjectsWith: renderingContext.
        foregroundLayer renderSceneObjectsWith: renderingContext.
    }.

    method renderShadowMaps => Void := {
        let stateTracker := stateTrackers current.

        0 until: activeShadowMapLayerCount do: {:i :: Void |
            let renderingContext mutable := ForwardSceneRenderingContext().

            self setupStateTracker: stateTracker forRenderPass: sceneRenderingPipeline _ shadowMapRenderPass on: sceneRenderingPipeline _ shadowMapFramebuffers[i]
                viewport: (RectangleI32 min: 0 max: (sceneRenderingPipeline _ shadowMapTextureExtent castTo: Int32x2)).

            renderingContext
                stateTracker: stateTracker;
                renderPass: SceneRenderPass DepthOnly;
                sceneRenderingPipeline: sceneRenderingPipeline getPointer;
                sceneBlendingEquation: BlendingMode Copy asBlendingEquation;
                sceneFaceCullingMode: FaceCullingMode Back;
                sceneDepthTestingEnabled: OverrideableBoolean True;
                sceneDepthWriteMask: OverrideableBoolean True.

            stateTracker _
                depthBiasConstantFactor: 4.0f;
                depthBiasSlopeFactor: 1.5f.

            shadowMapLayers[i] renderSceneObjectsWith: renderingContext.

            stateTracker _
                endRenderPass.
        }
    }.

    method renderDepthNormalPass => Void := {
        let stateTracker := stateTrackers current.

        self setupStateTracker: stateTracker forRenderPass: depthNormalRenderPass on: depthNormalFramebuffer.

        let renderingContext mutable := ForwardSceneRenderingContext().
        renderingContext
            stateTracker: stateTracker;
            renderPass: SceneRenderPass DepthNormal;
            sceneRenderingPipeline: sceneRenderingPipeline getPointer;
            sceneBlendingEquation: BlendingMode Copy asBlendingEquation;
            sceneFaceCullingMode: FaceCullingMode Back;
            sceneDepthTestingEnabled: OverrideableBoolean True;
            sceneDepthWriteMask: OverrideableBoolean True.

        self renderSceneObjectsWith: renderingContext.

        stateTracker _
            endRenderPass.
    }.

    method computeScreenSpaceAmbientOcclusion => Void := {
        let stateTracker := stateTrackers current.

        stateTracker _
            resetState;

            useShaderSignature: sceneRenderingPipeline _ shaderSignature;
            useGraphicShaderBindings: sceneRenderingPipeline _ samplingStateBinding;
            useGraphicShaderBindings: normalLayer cameraStateBindings current;
            useGraphicShaderBindings: ssaoComputationBinding;

            beginRenderPass: ssaoComputationRenderPass on: ssaoFramebuffer contentOnBundle: false;
            setViewport: (RectangleI32 min: Int32x2 zeros max: (ssaoTextureExtent castTo: Int32x2));
            setScissor: (RectangleI32 min: Int32x2 zeros max: (ssaoTextureExtent castTo: Int32x2));

            vertexShader: self screenQuadShader;
            fragmentShader: Woden Shaders SSAOComputationMaterialShaders ssaoComputation shaderEntryPointInfo address;
            primitiveTopology: PrimitiveTopology Triangles;
            drawArrays: 3 instanceCount: 1 firstVertex: 0 baseInstance: 0;

            endRenderPass
    }.

    method renderColorPass => Void := {
        let stateTracker := stateTrackers current.

        self setupStateTracker: stateTracker forRenderPass: hdrColorRenderPass on: hdrColorFramebuffer.

        let renderingContext mutable := ForwardSceneRenderingContext().
        renderingContext
            stateTracker: stateTracker;
            sceneRenderingPipeline: sceneRenderingPipeline getPointer;
            sceneBlendingEquation: BlendingMode Copy asBlendingEquation;
            sceneFaceCullingMode: FaceCullingMode Back;
            sceneDepthTestingEnabled: OverrideableBoolean True;
            sceneDepthWriteMask: OverrideableBoolean True.

        self renderSceneObjectsWith: renderingContext.

        stateTracker _
            endRenderPass.
    }.

    override method getLastFrameVisibleObjectCount => UIntPointer := {
        backgroundLayer renderableSceneObjects size + normalLayer renderableSceneObjects size + foregroundLayer renderableSceneObjects size
    }.

    override method prepareRendering ::=> Void := {
        let scene := sceneRenderingPipeline _ scene.
        scene ifNil: {return: void}.

        activeShadowMapLayerCount := 0.
        self
            prepareCameraState;
            prepareSceneLayer: scene _ backgroundLayer on: backgroundLayer;
            prepareSceneLayer: scene _ normalLayer on: normalLayer;
            prepareSceneLayer: scene _ foregroundLayer on: foregroundLayer;
            prepareShadowMapLayers.
    }.

    method renderHDRScene => Void := {
        let scene := sceneRenderingPipeline _ scene.
        scene ifNotNil: {
            hdrColorRenderPass _ setColorAttachment: 0 clearValue: scene _ backgroundColor.
        }.

        self
            renderDepthNormalPass;
            computeScreenSpaceAmbientOcclusion;
            renderColorPass
    }.

    method screenQuadShader => GPU ShaderEntryPointInfo const pointer := {
        self engine _ renderingDevice _ shouldInvertProjectionY ifTrue: {
            Woden Shaders CompositionMaterialShaders screenQuad shaderEntryPointInfo address
        } ifFalse: {
            Woden Shaders CompositionMaterialShaders screenQuadFlippedY shaderEntryPointInfo address
        }.
    }.

    method toneMappingShader => GPU ShaderEntryPointInfo const pointer := {
        toneMappingOperator selectCase: #{
            ToneMappingOperator Linear : Woden Shaders ToneMappingMaterialShaders linear shaderEntryPointInfo address.
            ToneMappingOperator Reinhard : Woden Shaders ToneMappingMaterialShaders reinhard shaderEntryPointInfo address.
            ToneMappingOperator Exponential : Woden Shaders ToneMappingMaterialShaders exponential shaderEntryPointInfo address.
            ToneMappingOperator Filmic : Woden Shaders ToneMappingMaterialShaders filmic shaderEntryPointInfo address.
            _ : Woden Shaders ToneMappingMaterialShaders filmic shaderEntryPointInfo address.
        }.
    }.

    method computeAverageLuminance => Void := {
        camera isNil || camera _ hasNoAutoExposure ifTrue: {return: void}.

        let stateTracker := stateTrackers current.
        stateTracker _
            resetState;
            useShaderSignature: sceneRenderingPipeline _ shaderSignature;
            useGraphicShaderBindings: sceneRenderingPipeline _ samplingStateBinding;
            useGraphicShaderBindings: normalLayer cameraStateBindings current;
            useGraphicShaderBindings: hdrColorBufferBinding.

        sceneRenderingPipeline _
            performAverageLuminanceComputationWith: stateTracker.

        stateTracker _
            useComputeShaderBindings: sceneRenderingPipeline _ samplingStateBinding;
            useComputeShaderBindings: normalLayer cameraStateBindings current;
            useComputeShaderBindings: sceneRenderingPipeline _ luminanceComputationResultMaterialBindings.

        sceneRenderingPipeline _
            performCameraAutoExposureStateComputationWith: stateTracker.

        stateTracker _
            buffer: cameraPostProcessingStateBuffer offset: 0 size: Woden Shaders CameraPostProcessingStateData instanceSize
            memoryBarrierFrom: PipelineStageMask ComputeShader accesses: AccessMask ShaderWrite | AccessMask ShaderRead
                to: PipelineStageMask FragmentShader accesses: AccessMask ShaderRead
    }.

    method renderScene2DOverlay => Void := {
        currentScene2D ifNil: { return: void }.

        let scene2DRenderer ref := scene2DRenderers[self engine _ frameBufferingIndex].
        scene2DRenderer ifNil: {
            scene2DRenderer := StateTracker2DSceneRenderer sharedNew.
            scene2DRenderer _
                device: self engine _ renderingDevice.
        }.

        scene2DRenderer _
            extent: currentExtent;
            stateTracker: stateTrackers current;
            renderScene: currentScene2D.
    }.

    method toneMapAndComposeHDRScene => Void := {
        let stateTracker := stateTrackers current.
        stateTracker _
            resetState;
            useShaderSignature: sceneRenderingPipeline _ shaderSignature;
            useGraphicShaderBindings: sceneRenderingPipeline _ samplingStateBinding;
            useGraphicShaderBindings: normalLayer cameraStateBindings current;
            useGraphicShaderBindings: hdrColorBufferBinding;

            beginRenderPass: currentDisplayRenderPass on: currentBackBuffer contentOnBundle: false;
            setViewport: (RectangleI32 min: Int32x2 zeros max: (currentExtent castTo: Int32x2));
            setScissor: (RectangleI32 min: Int32x2 zeros max: (currentExtent castTo: Int32x2));

            vertexShader: self screenQuadShader;
            fragmentShader: self toneMappingShader;
            primitiveTopology: PrimitiveTopology Triangles;
            drawArrays: 3 instanceCount: 1 firstVertex: 0 baseInstance: 0.

        self renderScene2DOverlay.

        stateTracker _
            endRenderPass
    }.

    override method setCurrentBackBuffer: (backBuffer: FramebufferPtr const ref) renderPass: (displayRenderPass: RenderPassPtr) ::=> Void := {
        currentDisplayRenderPass := displayRenderPass.
        currentBackBuffer := backBuffer.
    }.

    override method setScene2D: (scene2D: Stdn Graphics Scene2D NodePtr const ref) ::=> Void := {
        currentScene2D := scene2D
    }.

    override method scene2DBuilder => Stdn Graphics Scene2D BuilderPtr
        := self engine _ renderingDevice _ createScene2DBuilder.

    override method constructAndEnqueueCommandList => Void := {
        currentBackBuffer isNil || currentDisplayRenderPass isNil ifTrue: {
            return: void
        }.

        self
            uploadCameraState;
            uploadLightingState.

        let stateTracker := stateTrackers currentReseted.
        self
            renderShadowMaps;
            renderHDRScene;
            computeAverageLuminance;
            toneMapAndComposeHDRScene.

        stateTracker _
            close.

        self engine _ enqueueCommandList: (stateTracker upCastFor: CommandList).
    }.
}.

}. ## End of namespace ForwardRenderer
}. ## End of namespace Woden
