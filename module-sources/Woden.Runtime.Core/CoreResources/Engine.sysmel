namespace Woden definition: {
namespace Runtime definition: {

useNamespace: Stdn Graphics Core.
useNamespace: Stdn Graphics GUI.

compileTime if: Compiler compilationTarget isDesktopPC then: {
    compileTime constant FrameBufferingCount := 3.
    compileTime constant LargestSupportedIndexType := UInt32.
} else: {
    compileTime constant FrameBufferingCount := 2.
    compileTime constant LargestSupportedIndexType := UInt16.
}.

#**
 * I am core engine instance. I hold strong references to the core subsystem registries.
 *#
class Engine superclass: Stdn SharedObject; definition: {
    protected field windowSystem type: WindowSystemRef.
    protected field renderingDevice type: RenderingDevicePtr.
    protected field resourceCache type: ResourceCachePtr.

    protected field renderingProcessesMutex type: Stdn Mutex.
    protected field renderingProcesses type: Stdn Collections Vector(RenderingProcessWeakPtr).

    protected field frameBufferingIndex type: UInt32.
    protected field syncronizationFences type: (FencePtr array: FrameBufferingCount).
    protected field pendingCommandLists type: Stdn Collections Vector(CommandListPtr ).

    const inline method windowSystem => WindowSystemRef const ref
        := windowSystem.

    const inline method renderingDevice => RenderingDevicePtr const ref
        := renderingDevice.

    const inline method resourceCache => ResourceCachePtr const ref
        := resourceCache.

    const inline method mainLoopFrameCount => UInt32
        := windowSystem _ mainLoopFrameCount.

    const inline method frameBufferingIndex => UInt32
        := frameBufferingIndex.

    method registerRenderingProcess: (process: RenderingProcessWeakPtr) ::=> Void := {
        renderingProcessesMutex withLock: {
            renderingProcesses add: process
        }.
    }.

    method unregisterRenderingProcess: (process: RenderingProcessWeakPtr) ::=> Void := {
        renderingProcessesMutex withLock: {
            renderingProcesses remove: process
        }.
    }.

    method parseCommandLine: (arguments: Char8 const pointer arraySlice) ::=> Boolean8 := {
        true
    }.

    method initializeEngineWithCommandLine: (arguments: Char8 const pointer arraySlice) ::=> Boolean8
        := (self parseCommandLine: arguments) && self initializeEngine.

    method initializeEngine => Boolean8 := {
        windowSystem := createDefaultWindowSystem().
        windowSystem ifNil: { return: false }.

        windowSystem _ targetFrameRate: 60.

        renderingDevice := RenderingDriverRegistry defaultDriver _ getMainDevice.
        renderingDevice ifNil: {return: false }.

        self queryDeviceCapabilities.

        resourceCache := ResourceCache sharedNew.
        resourceCache _ initializeWithEngine: self asSharedPointer.

        true
    }.

    protected field projectiveTextureMatrix type: Float32x4x4.

    const inline method projectiveTextureMatrix => Float32x4x4
        := projectiveTextureMatrix.

    method queryDeviceCapabilities => Void := {
        ## Do we need to flip the texture coordinates when doing projective texturing?
        renderingDevice _ shouldInvertProjectionY not ifTrue: {
            projectiveTextureMatrix := Float32x4x4(
                0.5, 0, 0, 0,
                0, -0.5, 0, 0,
                0, 0, 1.0, 0,
                0.5, 0.5, 0, 1
            )
        } ifFalse: {
            projectiveTextureMatrix := Float32x4x4(
                0.5, 0, 0, 0,
                0, 0.5, 0, 0,
                0, 0, 1.0, 0,
                0.5, 0.5, 0, 1
            )
        }
    }.

    private field globalEventHandler type: EngineGlobalEventHandlerPtr.

    method runMainLoop => Int32 := {
        globalEventHandler := EngineGlobalEventHandler sharedNew.
        globalEventHandler _ engineWeakPtr: self asWeakPointer.
        windowSystem _ registerGlobalEventHandler: (globalEventHandler upCastFor: EventHandler).

        let result := windowSystem _ runMainLoop.

        windowSystem _ unregisterGlobalEventHandler: (globalEventHandler upCastFor: EventHandler).

        result
    }.

    method runMainLoopAndShutdown => Int32 := {
        let result := self runMainLoop.
        self shutdown.
        result
    }.

    method shutdown => Void := {
        ## Break the cycle between the resource cache and the engine.
        resourceCache reset.
    }.

    method enqueueCommandList: (commandList: CommandListPtr const ref) ::=> Void := {
        pendingCommandLists add: commandList
    }.

    method submitPendingCommandLists => Void := {
        pendingCommandLists ifEmpty: {return: void}.

        let commandQueue := renderingDevice _ getDefaultCommandQueue.
        pendingCommandLists do: {:each :: Void |
            commandQueue _ submitCommandList: each
        }.
        pendingCommandLists removeAll.
    }.

    method onTickEvent: (event: TickEvent ref) ::=> Void := {
        let thisFrameProcesses mutable type: Stdn Collections Vector(RenderingProcessPtr).
        let thisFrameRenderingProcesses mutable type: Stdn Collections Vector(RenderingProcessPtr).
        pendingCommandLists removeAll.

        ## Get a copy of the rendering processes for this frame.
        renderingProcessesMutex withLock: {
            thisFrameProcesses reserve: renderingProcesses size.
            renderingProcesses do: {:each :: Void |
                let process := each lock.
                process ifNotNil: {
                    thisFrameProcesses add: process
                }.
            }
        }.

        ## Send the tick event to the rendering processes.
        thisFrameProcesses do: {:each :: Void |
            each _ onStartFrameTick: event
        }.

        ## Select the rendering processes that need to render.
        thisFrameRenderingProcesses reserve: renderingProcesses size.
        thisFrameProcesses do: {:each :: Void |
            each _ needsToRender ifTrue: {
                thisFrameRenderingProcesses add: each.
            }.
        }.

        thisFrameRenderingProcesses ifEmpty: {
            return: void
        }.

        let fence ref := syncronizationFences[frameBufferingIndex].
        fence ifNotNil: {
            fence _ wait
        }.

        ## First phase: prepare rendering.
        thisFrameRenderingProcesses do: {:each :: Void |
            each _ prepareRendering.
        }.

        ## Second phase: command list construction
        thisFrameRenderingProcesses do: {:each :: Void |
            each _ constructRenderingCommandList.
        }.

        ## Third phase: command list submission
        self submitPendingCommandLists.

        ## Fourth phase: drawing surface commiting
        thisFrameRenderingProcesses do: {:each :: Void |
            each _ commitSurfaces.
        }.

        fence ifNil: {
            fence := renderingDevice _ createFence
        }.

        fence ifNotNil: {
            renderingDevice _ getDefaultCommandQueue _ signalFence: fence
        }.
        frameBufferingIndex := (frameBufferingIndex + 1) % FrameBufferingCount.
    }.
}.

compileTime constant EnginePtr := Engine sharedPointer.
compileTime constant EngineWeakPtr := Engine weakPointer.

class EngineGlobalEventHandler superclass: EventHandler; definition: {
    public field engineWeakPtr type: EngineWeakPtr.

    override method onTickEvent: (event: TickEvent ref) ::=> Void := {
        let engine := engineWeakPtr lock.
        engine ifNotNil: {
            engine _ onTickEvent: event
        }
    }.
}.

compileTime constant EngineGlobalEventHandlerPtr := EngineGlobalEventHandler sharedPointer.


}. ## End of namespace Runtime
}. ## End of namespace Woden
