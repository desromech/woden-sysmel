namespace Woden definition: {
namespace Runtime definition: {

useNamespace: Stdn Math Geometry.
useNamespace: Stdn Math LinearAlgebra.

#**
 * I represent a 3D scene with rendering only objects.
 *#
class SceneNode superclass: Stdn SharedObject; definition: {
    protected field parentWeakPtr type: SceneNode weakPointer.
    protected field sceneWeakPtr type: Scene weakPointer.
    protected field children type: Stdn Collections Vector(SceneNodePtr).
    protected field transform type: ReversibleAffineTransform3dF32.

    private field globalTransform type: ReversibleAffineTransform3dF32.
    private field globalTransformIsValid type: Boolean8.

    override method initialize => Void := {
        transform setIdentity.
    }.

    const inline method parent => SceneNodePtr
        := parentWeakPtr lock.

    const inline method scene => ScenePtr
        := sceneWeakPtr lock.

    virtual method sceneLayer => SceneLayer pointer := {
        let p := self parent.
        p ifNotNil: {
            return: p _ sceneLayer
        }.

        nil
    }.

    const inline method transform => ReversibleAffineTransform3dF32
        := transform.

    inline method transform: (newTransform: ReversibleAffineTransform3dF32) ::=> Void := {
        transform := newTransform.
        self transformChanged.
    }.

    method transformChanged => Void := {
        self parent ifNotNil: {:p :: Void |
            p _ childTransformChanged: self
        }.

        self parentTransformChanged.
    }.

    method childTransformChanged: (aChild: SceneNode ref) ::=> Void := {

    }.

    virtual method globalTransformChanged => Void := {
        globalTransformIsValid := false.
    }.

    method parentTransformChanged => Void := {
        self globalTransformChanged.
        children do: {:each :: Void |
            each _ parentTransformChanged
        }
    }.

    inline method globalTransform => ReversibleAffineTransform3dF32 := {
        globalTransformIsValid ifFalse: { self validateGlobalTransform }.
        globalTransform
    }.

    method validateGlobalTransform => Void := {
        self parent ifNil: {
            globalTransform := transform.
        } ifNotNil: {:p :: Void |
            globalTransform := p _ globalTransform transformTransform: transform
        }.

        globalTransformIsValid := true.
    }.

    virtual method addedToScene: (aScene: ScenePtr const ref) ::=> Void := {
        sceneWeakPtr := aScene asWeakPointer.
        self sceneLayer ifNotNil: {:layer :: Void |
            self addRenderingSceneObjectsToSceneLayer: layer _
        }.

        children do: {:each :: Void |
            each _ addedToScene: aScene
        }.
    }.

    virtual method removedFromScene: (aScene: ScenePtr const ref) ::=> Void := {
        self sceneLayer ifNotNil: {:layer :: Void |
            self removeRenderingSceneObjectsFromSceneLayer: layer _
        }.

        children do: {:each :: Void |
            each _ removedFromScene: aScene
        }.

        sceneWeakPtr reset.
    }.

    virtual method addedToNode: (newParentNode: SceneNodePtr const ref) ::=> Void := {
        parentWeakPtr := newParentNode asWeakPointer.
        let parentScene := newParentNode _ scene.
        parentScene ifNotNil: {
            self addedToScene: parentScene
        }.
    }.

    virtual method removedFromNode: (newParentNode: SceneNodePtr const ref) ::=> Void := {
        let oldScene := self scene.
        oldScene ifNotNil: { self removedFromScene: oldScene }.
        parentWeakPtr reset
    }.

    virtual method addRenderingSceneObjectsToSceneLayer: (sceneLayer: SceneLayer ref) ::=> Void := {

    }.

    virtual method removeRenderingSceneObjectsFromSceneLayer: (sceneLayer: SceneLayer ref) ::=> Void := {

    }.

    method addChild: (aChild: SceneNodePtr const ref) ::=> Void := {
        aChild _ addedToNode: self asSharedPointer.
        children add: aChild.
    }.

    inline method scaleBy: (scale: Float32x3) ::=> Void := {
        transform scaleBy: scale.
        self transformChanged.
    }.

    inline method scaleByX: (x: Float32) y: (y: Float32) z: (z: Float32) ::=> Void := {
        transform scaleByX: x y: y z: z.
        self transformChanged.
    }.

    inline method rotateDegreesOnX: (x: Float32) ::=> Void := {
        transform rotateDegreesOnX: x.
        self transformChanged.
    }.

    inline method rotateDegreesOnY: (y: Float32) ::=> Void := {
        transform rotateDegreesOnY: y.
        self transformChanged.
    }.

    inline method rotateDegreesOnZ: (z: Float32) ::=> Void := {
        transform rotateDegreesOnY: z.
        self transformChanged.
    }.

    inline method rotateRadiansOnX: (x: Float32) ::=> Void := {
        transform rotateRadiansOnX: x.
        self transformChanged.
    }.

    inline method rotateRadiansOnY: (y: Float32) ::=> Void := {
        transform rotateRadiansOnY: y.
        self transformChanged.
    }.

    inline method rotateRadiansOnZ: (z: Float32) ::=> Void := {
        transform rotateRadiansOnY: z.
        self transformChanged.
    }.

    inline method translateToX: (x: Float32) ::=> Void := {
        transform translateToX: x.
        self transformChanged.
    }.

    inline method translateToY: (y: Float32) ::=> Void := {
        transform translateToY: y.
        self transformChanged.
    }.

    inline method translateToZ: (z: Float32) ::=> Void := {
        transform translateToZ: z.
        self transformChanged.
    }.

    inline method translateToX: (x: Float32) y: (y: Float32) z: (z: Float32) ::=> Void := {
        transform translateToX: x y: y z: z.
        self transformChanged.
    }.

    inline method translateTo: (delta: Float32x3) ::=> Void := {
        transform translateTo: delta.
        self transformChanged.
    }.

    inline method translateByX: (x: Float32) ::=> Void := {
        transform translateByX: x.
        self transformChanged.
    }.

    inline method translateByY: (y: Float32) ::=> Void := {
        transform translateByY: y.
        self transformChanged.
    }.

    inline method translateByZ: (z: Float32) ::=> Void := {
        transform translateByZ: z.
        self transformChanged.
    }.

    inline method translateByX: (x: Float32) y: (y: Float32) z: (z: Float32) ::=> Void := {
        transform translateByX: x y: y z: z.
        self transformChanged.
    }.

    inline method translateBy: (delta: Float32x3) ::=> Void := {
        transform translateBy: delta.
        self transformChanged.
    }.

    method allNodesDo: (aBlock: SceneNodeIterationBlock) ::=> Void := {
        children do: {:each :: Void |
            each _ withAllNodesDo: aBlock
        }
    }.

    method withAllNodesDo: (aBlock: SceneNodeIterationBlock) ::=> Void := {
        aBlock(self).
        self allNodesDo: aBlock
    }.

    const virtual method isAbstractSpatialObjectNode => Boolean8
        := false.

    const virtual method isCamera => Boolean8
        := false.

    const virtual method isLightSourceNode => Boolean8
        := false.

    const virtual method isSceneLayer => Boolean8
        := false.

    const virtual method isSpatialObjectNode => Boolean8
        := false.

    virtual method validateRenderingSceneObjectTransform: (renderingSceneObject: RenderingSceneObject ref) ::=> Void := {
        renderingSceneObject spatialObject _ setCurrentTransform: self globalTransform.
        renderingSceneObject boundingBox: (renderingSceneObject localBoundingBox transformedWith: globalTransform)
    }.
}.

compileTime constant SceneNodeIterationBlock := ((SceneNode ref) => Void) nativeBlockClosure.

compileTime constant SceneNodePtr := SceneNode sharedPointer.
compileTime constant SceneNodeWeakPtr := SceneNode weakPointer.

}. ## End of namespace Runtime
}. ## End of namespace Woden
